1
00:00:00,000 --> 00:00:08,740
До сих пор мы видели множество команд Linux для разных случаев использования, например для вывода содержимого

2
00:00:08,740 --> 00:00:17,040
каталога, создания пользователей и назначения их в группы и т.д.

3
00:00:17,040 --> 00:00:23,200
И в Linux у каждой команды могут быть вход и выход.

4
00:00:23,200 --> 00:00:30,920
И есть ещё одно очень важное понятие в Linux, которое позволяет выводу одной команды

5
00:00:30,920 --> 00:00:34,400
быть входом другой команды.

6
00:00:34,400 --> 00:00:40,160
То есть вы можете цепочкой выполнить несколько команд в интерфейсе командной строки,

7
00:00:40,160 --> 00:00:47,960
например, и использовать результат выполнения одной команды как вход

8
00:00:47,960 --> 00:00:49,560
для другой команды.

9
00:00:49,560 --> 00:00:56,320
То есть идея в том, что вывод одной программы может стать входом другой программы.

10
00:00:56,320 --> 00:01:02,240
И давайте на примерах, что я имею в виду, например, допустим, у нас есть такой файл,

11
00:01:02,240 --> 00:01:06,200
как syslog, который мы хотим показать.

12
00:01:06,200 --> 00:01:12,600
И он находится в var, это каталог, где хранятся многие файлы журналов, например, или кеши,

13
00:01:12,600 --> 00:01:20,560
затем там есть каталог log, в котором есть системный или syslog файл.

14
00:01:20,560 --> 00:01:26,160
Итак, если я выведу содержимое файла syslog, вы увидите, что там очень много

15
00:01:26,160 --> 00:01:33,360
записей журнала, потому что он по сути собирает и записывает каждую вещь, которую вы

16
00:01:33,360 --> 00:01:38,080
делаете в системе: открытие программ, создание папок и файлов и т.д.

17
00:01:38,080 --> 00:01:47,080
Так что вам придётся прокручивать терминал, чтобы увидеть начало файла.

18
00:01:47,080 --> 00:01:53,800
Теперь если мы хотим увидеть содержимое в интерфейсе командной строки более удобным

19
00:01:53,800 --> 00:02:00,320
и дружелюбным способом, мы можем взять вывод этой команды.

20
00:02:00,320 --> 00:02:09,680
То есть содержимое файла, которое даёт нам команда concatenate, и передать его

21
00:02:09,680 --> 00:02:16,720
на вход программе, способной показывать большой контент постранично.

22
00:02:16,720 --> 00:02:19,720
Эта программа называется less.

23
00:02:19,720 --> 00:02:29,000
А синтаксис передачи вывода следующей команде в качестве входа — это символ pipe,

24
00:02:29,000 --> 00:02:34,800
который выглядит вот так, и в зависимости от раскладки клавиатуры и языка у вас

25
00:02:34,800 --> 00:02:36,920
это будет другая комбинация клавиш.

26
00:02:36,920 --> 00:02:44,200
И затем программа, которой мы передаём вход, то есть имя этой программы.

27
00:02:44,200 --> 00:02:50,600
А сама концепция передачи вывода одной команды следующей называется

28
00:02:50,600 --> 00:02:52,200
пайпинг.

29
00:02:52,200 --> 00:02:58,440
То есть мы направляем вывод команды concatenate в less, который, как я говорил, less

30
00:02:58,440 --> 00:03:07,120
— это программа, которая отображает большие части информации текстовых файлов более удобным

31
00:03:07,120 --> 00:03:08,840
образом вот так.

32
00:03:08,840 --> 00:03:11,280
Так что мы можем читать это постранично.

33
00:03:11,280 --> 00:03:15,800
Итак, это начало, старт содержимого файла.

34
00:03:15,800 --> 00:03:17,280
И это одна страница.

35
00:03:17,280 --> 00:03:25,960
А клавишей пробел вы можете прыгать на следующую страницу вот так и до

36
00:03:25,960 --> 00:03:27,360
конца.

37
00:03:27,360 --> 00:03:34,960
А когда дойдёте до конца, вы можете просто нажать Q, и это завершит программу.

38
00:03:34,960 --> 00:03:42,200
Итак, как вы видели, у нас нет вывода программы concatenate в самом терминале,

39
00:03:42,200 --> 00:03:43,520
как мы делали здесь.

40
00:03:43,520 --> 00:03:49,400
То есть здесь она просто распечатала всё прямо в интерфейсе командной строки.

41
00:03:49,400 --> 00:03:54,240
Но с этой строкой она ничего не вывела в командную строку.

42
00:03:54,240 --> 00:03:55,240
Почему?

43
00:03:55,720 --> 00:04:04,040
Мы перенаправили эту печать или этот результат, содержимое того файла, в другую программу,

44
00:04:04,040 --> 00:04:09,360
которая не печатает вывод в интерфейс командной строки, а просто позволяет вам

45
00:04:09,360 --> 00:04:11,520
читать его в этом интерактивном режиме.

46
00:04:11,520 --> 00:04:14,400
Вот в основном концепция пайпинга.

47
00:04:14,400 --> 00:04:20,160
А теперь давайте посмотрим ещё пару случаев использования, где вы увидите, что это действительно

48
00:04:20,160 --> 00:04:24,520
очень полезно во многих ситуациях.

49
00:04:24,520 --> 00:04:30,880
Давайте очистим это.

50
00:04:30,880 --> 00:04:41,720
И теперь давайте выведем содержимое папки slash user slash bin.

51
00:04:41,720 --> 00:04:51,120
И как видите, в той папке много разных программ и исполняемых файлов.

52
00:04:51,120 --> 00:04:55,000
которые все выводятся прямо здесь.

53
00:04:55,000 --> 00:05:03,920
Опять же, не очень удобно постоянно прокручивать вверх и вниз, чтобы увидеть первые записи

54
00:05:03,920 --> 00:05:04,920
команды.

55
00:05:04,920 --> 00:05:14,320
Точно так же мы можем направить вывод, который опять же показывает все эти имена файлов,

56
00:05:14,320 --> 00:05:20,760
по сути передать это как ввод программе less.

57
00:05:20,760 --> 00:05:30,920
И это даст нам постраничный просмотр всех этих содержимых каталога.

58
00:05:30,920 --> 00:05:36,320
Мы видим, что оно начинается с a, это первая страница, затем следующая и, по сути,

59
00:05:36,320 --> 00:05:41,480
используя пробел, вы можете перейти на следующую страницу.

60
00:05:41,480 --> 00:05:47,280
Если хотите перейти на предыдущую страницу, можно просто нажать клавишу B, и это

61
00:05:47,280 --> 00:05:50,360
по сути вернет вас назад и так далее.

62
00:05:50,360 --> 00:05:57,080
Есть и другие подкоманды less, которые можно здесь использовать для навигации по

63
00:05:57,080 --> 00:06:02,440
этому просмотру, вместо того чтобы просто иметь статичный вывод в командной строке,

64
00:06:02,440 --> 00:06:05,480
который нужно прокручивать вверх и вниз, чтобы его увидеть.

65
00:06:05,480 --> 00:06:09,960
И снова, если я нажму здесь Q, программа просто завершится.

66
00:06:09,960 --> 00:06:17,720
Так намного удобнее потреблять информацию, у которой, по сути, несколько страниц отображения.

67
00:06:17,720 --> 00:06:24,920
Еще один очень полезный случай, где можно использовать программу less, чтобы, по сути, смотреть вывод

68
00:06:24,920 --> 00:06:31,400
в более управляемом виде, — если вы хотите вывести историю своих команд, верно?

69
00:06:31,400 --> 00:06:37,120
Если вы выполняете кучу команд в своей операционной системе, у вас будет много

70
00:06:37,120 --> 00:06:39,120
команд, верно?

71
00:06:39,120 --> 00:06:43,600
Мы работаем на этой операционной системе всего пару дней, и у нас уже

72
00:06:43,600 --> 00:06:45,880
несколько сотен команд здесь.

73
00:06:45,880 --> 00:06:56,840
Поэтому, если вы не хотите, чтобы вся эта история была распечатана здесь в окне терминала,

74
00:06:56,840 --> 00:06:57,760
мы можем сделать то же самое.

75
00:06:57,760 --> 00:07:06,840
Можно сделать history, pipe, все, что команда history выдаст, в программу less, чтобы она могла отображать

76
00:07:06,840 --> 00:07:07,840
это лучше.

77
00:07:07,840 --> 00:07:12,960
Снова видите самую первую команду, которую мы выполнили, — вот эту прямо здесь.

78
00:07:12,960 --> 00:07:21,400
И затем снова мы можем перемещаться вперед и назад, используя пробел для следующей страницы и B для предыдущей

79
00:07:21,400 --> 00:07:24,000
страницы и Q для выхода.

80
00:07:24,000 --> 00:07:31,360
Так что это некоторые полезные случаи использования пайпинга и конкретно отправки большого количества

81
00:07:31,360 --> 00:07:39,960
вывода в программу less, но это лишь один пример.

82
00:07:39,960 --> 00:07:45,000
Мы можем направлять вывод команд в любую другую программу.

83
00:07:45,000 --> 00:07:49,400
Например, давайте возьмем снова команду history.

84
00:07:49,400 --> 00:07:57,400
И скажем, мы хотим отфильтровать все команды, которые содержат sudo.

85
00:07:57,400 --> 00:08:06,280
То есть хотим увидеть все команды, которые мы выполняли с sudo как суперпользователь.

86
00:08:06,280 --> 00:08:08,640
И как это сделать?

87
00:08:08,640 --> 00:08:10,920
Снова history через pipe.

88
00:08:10,920 --> 00:08:19,280
И есть другая программа, которая умеет фильтровать любой вывод, который вы даете ей на вход.

89
00:08:19,280 --> 00:08:27,040
Она называется g R E P, и эта программа принимает строку фильтра как ввод в дополнение

90
00:08:27,040 --> 00:08:31,320
к содержимому, которое она должна отфильтровать, верно?

91
00:08:31,320 --> 00:08:37,560
То есть у нее есть содержимое, в котором она должна искать определенный шаблон и отфильтровать

92
00:08:37,560 --> 00:08:38,560
результаты.

93
00:08:38,560 --> 00:08:42,480
Так что мы можем сделать grep sudo.

94
00:08:42,480 --> 00:08:50,400
То есть искать любые команды, которые history выдает как вывод,

95
00:08:50,400 --> 00:08:51,400
и в которых есть слово sudo.

96
00:08:51,400 --> 00:08:58,800
Если я выполню, вы увидите, что grep, во-первых, выводит эти команды.

97
00:08:58,800 --> 00:09:00,080
также в интерфейсе командной строки.

98
00:09:00,080 --> 00:09:01,960
Так что мы видим это здесь.

99
00:09:01,960 --> 00:09:07,960
И прежде всего мы видим, что слово, которое мы ищем, подсвечено цветом,

100
00:09:07,960 --> 00:09:11,160
что очень приятно смотрится.

101
00:09:11,160 --> 00:09:12,920
Так что мы можем увидеть это сразу.

102
00:09:12,920 --> 00:09:17,000
Плюс у нас есть список всех команд, которые мы выполняли с помощью sudo.

103
00:09:17,000 --> 00:09:24,200
Так что это отличная прослеживаемость на случай, если нам нужна по сути история всех sudo

104
00:09:24,200 --> 00:09:25,200
команд.

105
00:09:25,200 --> 00:09:32,680
Шаблон фильтра здесь, строка, которую мы передаем или даем программе grep для поиска

106
00:09:32,680 --> 00:09:36,240
может быть любой, какой вы хотите.

107
00:09:36,240 --> 00:09:39,480
Это может быть часть настоящего слова.

108
00:09:39,480 --> 00:09:43,640
Она может быть в начале строки, в конце — это неважно.

109
00:09:43,640 --> 00:09:50,840
Мы также можем искать несколько слов или фактически предложения или фразы с помощью этой команды grep.

110
00:09:50,840 --> 00:09:57,480
Например, мы хотим увидеть все команды sudo, которые мы выполняли для изменения файловых

111
00:09:57,480 --> 00:09:59,360
разрешений, да?

112
00:09:59,360 --> 00:10:08,560
То есть sudo change mode, например, однако в этом случае нам нужно, по сути, сказать grep

113
00:10:08,560 --> 00:10:12,640
программе явно, что это фраза, которую мы ищем.

114
00:10:12,640 --> 00:10:16,420
И нам нужно заключить её в двойные кавычки.

115
00:10:16,420 --> 00:10:24,020
То есть если у нас одно слово, без пробелов, мы можем делать это без кавычек, иначе

116
00:10:24,020 --> 00:10:27,340
нужно заключать предложение или фразу в кавычки.

117
00:10:27,340 --> 00:10:33,300
И снова выполняем, и теперь видим команды sudo change mode.

118
00:10:33,300 --> 00:10:40,980
Как я сказал, любая команда может принимать ввод из вывода предыдущей команды.

119
00:10:40,980 --> 00:10:49,340
Это значит, что мы можем передать вывод этой команды также следующей команде.

120
00:10:49,340 --> 00:10:55,260
Например, давайте очистим это.

121
00:10:55,260 --> 00:11:02,300
И посмотрим, что этот grep, например, всё ещё выдаёт массу вывода, верно?

122
00:11:02,300 --> 00:11:08,020
Допустим, он даёт нам сотни записей, потому что мы выполняли много команд

123
00:11:08,020 --> 00:11:09,540
с использованием sudo.

124
00:11:09,540 --> 00:11:16,860
Поэтому мы хотим увидеть это в удобоваримом и более дружелюбном виде.

125
00:11:16,860 --> 00:11:22,500
Мы можем на самом деле передать это по пайпу другой программе, например less.

126
00:11:22,500 --> 00:11:28,860
Теперь произойдёт следующее: history по сути даст нам все записи истории.

127
00:11:28,860 --> 00:11:35,300
Затем он передаст этот вывод программе grep, которая отфильтрует всю историю

128
00:11:35,300 --> 00:11:42,180
выводов, и та затем выдаст свой вывод или передаст его как параметр следующей программе.

129
00:11:42,180 --> 00:11:49,220
Теперь, если я это выполняю, вы видите записи sudo, которые выводит программа less.

130
00:11:49,220 --> 00:11:55,500
И снова вы можете переходить на следующую страницу, на предыдущую и так далее.

131
00:11:55,500 --> 00:12:02,300
И у вас может быть эта бесконечная цепочка команд, используя концепцию пайпов.

132
00:12:02,300 --> 00:12:08,140
И команду grep можно использовать для фильтрации определённых строк в любом типе содержимого.

133
00:12:08,140 --> 00:12:09,580
Это может быть содержимое файлов.

134
00:12:09,580 --> 00:12:15,180
Это может быть список команд или список файлов и папок.

135
00:12:15,180 --> 00:12:24,460
Чтобы посмотреть другой пример, допустим, мы хотим отфильтровать все файлы внутри этого

136
00:12:24,460 --> 00:12:30,660
каталога usr/bin, чтобы найти конкретную программу или приложение.

137
00:12:30,660 --> 00:12:38,900
Потому что если я нажму здесь таб-дополнение, оно покажет, что тут 1386 записей

138
00:12:38,900 --> 00:12:39,900
в этой папке.

139
00:12:39,900 --> 00:12:42,660
Очевидно, мы не хотим выводить их все, правда?

140
00:12:42,660 --> 00:12:51,340
Вместо этого мы можем выполнить grep по конкретной программе, например Java, и это покажет

141
00:12:51,340 --> 00:12:59,940
есть ли программа Java в этом каталоге bin.

142
00:12:59,940 --> 00:13:05,580
Мы можем сделать то же для Python, что, как видите, показывает, что здесь несколько файлов Python

143
00:13:05,580 --> 00:13:06,820
присутствуют.

144
00:13:06,820 --> 00:13:13,900
То есть программу grep можно использовать, чтобы узнать, есть ли определённый файл или программа

145
00:13:13,900 --> 00:13:16,100
или что-либо ещё в каталоге.

146
00:13:16,100 --> 00:13:23,660
И мы также можем использовать её, чтобы находить конкретные фразы или тексты в содержимом файла.

147
00:13:23,660 --> 00:13:33,020
Например, в нашем Java-проекте есть YAML-файл конфигурации с некоторым содержимым.

148
00:13:33,020 --> 00:13:38,740
И допустим, если бы это был гораздо больший YAML-файл с множеством строк кода, мы могли бы

149
00:13:38,740 --> 00:13:47,180
выполнить grep по конкретному значению, например увидеть все места, где порты

150
00:13:47,180 --> 00:13:57,580
определены, используя строку ports как фильтр, или номер порта как фильтр, вот так.

151
00:13:57,580 --> 00:14:03,060
Итак, это некоторые варианты использования, где концепция конвейера или, по сути, передачи

152
00:14:03,060 --> 00:14:12,220
вывода одной команды в следующую как ввода может быть очень полезной.

153
00:14:12,220 --> 00:14:19,300
Еще одна похожая концепция в Linux, которая также очень помогает во многих случаях, называется

154
00:14:19,300 --> 00:14:20,460
перенаправление.

155
00:14:20,460 --> 00:14:28,020
То есть мы, по сути, перенаправляем результаты выполнения команды, например, в файл.

156
00:14:28,020 --> 00:14:31,620
Давайте снова посмотрим конкретный пример использования.

157
00:14:31,620 --> 00:14:40,220
Ранее мы видели, что отфильтровали все записи истории или команды sudo, вот так.

158
00:14:40,220 --> 00:14:46,180
Теперь скажем, мы хотим сохранить этот вывод в файл, потому что, не знаю, возможно, мы

159
00:14:46,180 --> 00:14:51,660
хотим оставить его на потом как историю, поделиться с кем-то в нашей команде, неважно.

160
00:14:51,660 --> 00:14:54,900
То есть, по сути, мы хотим иметь все это в файле.

161
00:14:54,900 --> 00:15:07,820
Мы можем сделать это очень просто, перенаправив результат выполнения этих программ в

162
00:15:07,820 --> 00:15:14,620
файл с помощью этого знака больше, который также немного похож на стрелку с направлением,

163
00:15:14,620 --> 00:15:21,420
что логично, потому что мы по сути помещаем или направляем вывод этой

164
00:15:21,420 --> 00:15:23,620
команды сюда в файл.

165
00:15:23,620 --> 00:15:25,700
И мы можем назвать этот файл как захотим.

166
00:15:25,700 --> 00:15:35,900
Я назову его pseudo commands dot txt или dot ch, особой разницы нет, и

167
00:15:35,900 --> 00:15:36,900
выполню.

168
00:15:36,900 --> 00:15:44,660
Теперь, если я сделаю LS, вот мой файл pseudo commands dot text, в котором то же содержимое

169
00:15:44,660 --> 00:15:52,660
что и вывод этих двух команд.

170
00:15:52,660 --> 00:15:57,700
И теперь у нас есть файл, которым можно делиться и переносить.

171
00:15:57,700 --> 00:16:04,020
Теперь скажем, мы решили, знаешь что, мы хотим добавить некоторые другие команды в

172
00:16:04,020 --> 00:16:15,180
файл pseudo commands dot text, помимо того, что там уже есть.

173
00:16:15,180 --> 00:16:20,420
Например, это могут быть все команды удаления, которые мы выполняли в системе.

174
00:16:20,420 --> 00:16:25,940
Мы хотим их тоже в этом файле команд.

175
00:16:25,940 --> 00:16:31,180
В дополнение к тому, что у нас есть в файле pseudo commands, но как отдельный

176
00:16:31,180 --> 00:16:32,180
файл.

177
00:16:32,180 --> 00:16:37,340
Так что мы можем сделать — фактически скопировать содержимое, все, что здесь есть, в новый

178
00:16:37,340 --> 00:16:43,980
файл, также используя перенаправление вывода одной команды в другую.

179
00:16:43,980 --> 00:16:51,380
Скажем, мы конкатенируем содержимое этого файла, а затем перенаправляем его в

180
00:16:51,380 --> 00:16:52,380
другой файл.

181
00:16:52,380 --> 00:16:58,420
И допустим, это pseudo и remove comments.

182
00:16:58,420 --> 00:17:04,420
Так мы это назовем, выполняем.

183
00:17:04,420 --> 00:17:12,860
И теперь, если вывести содержимое, вы видите, что здесь точно такое же содержимое.

184
00:17:12,860 --> 00:17:22,020
И, как я сказал, мы хотим добавить в этот файл все команды, которые по сути что-то удаляли

185
00:17:22,020 --> 00:17:23,460
в системе.

186
00:17:23,460 --> 00:17:28,820
Итак, если я выполню это, вот результаты.

187
00:17:28,820 --> 00:17:38,180
И мы также можем перенаправить все это в pseudo remove comments.

188
00:17:38,180 --> 00:17:47,940
Однако обратите внимание, что если я использую такой синтаксис, то все, что есть в существующем содержимом,

189
00:17:47,940 --> 00:17:49,980
здесь будет перезаписано.

190
00:17:49,980 --> 00:17:56,180
То есть эти строки фактически перезапишут все, что внутри.

191
00:17:56,180 --> 00:18:01,900
Если я хочу добавить новые строки или новое содержимое к существующему, тогда мне нужно использовать

192
00:18:01,900 --> 00:18:06,340
синтаксис с двойными знаками больше.

193
00:18:06,340 --> 00:18:14,380
Снова, если я выполню и покажу или выведу содержимое, вот, у нас есть pseudo

194
00:18:14,380 --> 00:18:22,380
comments, которые были раньше, плюс remove comments добавились дополнительно.

195
00:18:22,380 --> 00:18:29,900
Теперь очень полезный пример, где конвейеризация и перенаправление вывода команд могут быть

196
00:18:29,900 --> 00:18:38,820
использованы, например, если вы собираете логи программы, которая, возможно, печатает в

197
00:18:38,820 --> 00:18:44,140
командную строку, то есть в консоль, чтобы можно было собрать все эти логи, отфильтровать

198
00:18:44,140 --> 00:18:49,860
их и сохранить в файл, а затем либо сделать резервную копию, либо поделиться

199
00:18:49,860 --> 00:18:56,420
с кем-то для устранения неполадок и т.д.

200
00:18:56,420 --> 00:19:03,860
Итак, это некоторые варианты использования концепций конвейеров и перенаправления в Linux, чтобы

201
00:19:03,860 --> 00:19:10,140
по сути, объединяют несколько выполнений команд и делают с этим что-то полезное.

202
00:19:10,140 --> 00:19:15,420
Вы запускаете одну команду или одну программу, а затем перенаправляете или отправляете через pipe её вывод

203
00:19:15,420 --> 00:19:19,300
в другую команду, потом в следующую и так далее.

204
00:19:19,300 --> 00:19:24,940
И как я упоминал в самом начале, каждая команда в Linux может иметь вход и

205
00:19:24,940 --> 00:19:26,620
выход.

206
00:19:26,620 --> 00:19:33,540
И у этих входа и выхода в Linux есть официальные термины — стандартный

207
00:19:33,540 --> 00:19:39,860
ввод или STD in и стандартный вывод STD out.

208
00:19:39,860 --> 00:19:45,300
То есть, говоря об этих терминах, мы имеем в виду перенаправление или передачу через pipe стандартного вывода из одной

209
00:19:45,300 --> 00:19:48,580
команды в стандартный ввод другой команды.

210
00:19:48,580 --> 00:19:55,980
Однако, если команда приводит к ошибке, например, мы пытаемся показать

211
00:19:55,980 --> 00:20:07,020
файл, которого не существует, то будет показано сообщение об ошибке через поток стандартных ошибок,

212
00:20:07,020 --> 00:20:08,020
верно?

213
00:20:08,020 --> 00:20:12,380
То есть помимо потока ввода у нас есть поток вывода для успешных результатов, а ещё есть

214
00:20:12,380 --> 00:20:16,820
поток ошибок, или вывод ошибок, как здесь.

215
00:20:16,820 --> 00:20:18,540
То есть снова, концепции очень похожи.

216
00:20:18,540 --> 00:20:23,100
Но если вы встретите эти термины, вы будете понимать, о чём идёт речь.

217
00:20:23,100 --> 00:20:29,300
И последнее, что я хотел здесь отметить: вы можете также выполнять

218
00:20:29,300 --> 00:20:35,020
команды независимо друг от друга, не разделяя потоки ввода и вывода, просто одну

219
00:20:35,020 --> 00:20:38,300
за другой в одной строке.

220
00:20:38,300 --> 00:20:42,340
Сделать это можно, разделив их точками с запятой.

221
00:20:42,340 --> 00:20:46,620
Хороший пример: допустим, у нас есть команда clear.

222
00:20:46,620 --> 00:20:53,500
А после этого мы хотим выполнить команду sleep, которая ждёт пару

223
00:20:53,500 --> 00:21:00,820
секунд, а затем выполнить ещё одну команду, например echo, которая просто выводит в

224
00:21:00,820 --> 00:21:14,540
консоль всё, что мы передадим на вход, например это предложение.

225
00:21:14,540 --> 00:21:19,380
И если я это выполню, снова, они не разделяют никакого вывода или ввода.

226
00:21:19,380 --> 00:21:25,300
Это просто независимо выполняемые команды, которые выполнятся одна за другой

227
00:21:25,300 --> 00:21:26,300
в таком порядке.

228
00:21:26,660 --> 00:21:36,460
Как видите, сначала выполнилась clear, затем прошла одна секунда, и потом мы увидели выполнение echo.

229
00:21:36,460 --> 00:21:42,660
И это тоже может быть полезно знать, если вы пишете, например, одну строку, где

230
00:21:42,660 --> 00:21:46,220
хотите, чтобы несколько команд выполнялись одна за другой.

231
00:21:46,220 --> 00:21:52,580
Итак, в этом уроке мы узнали о очень важных концепциях в Linux, а именно о пайпинге

232
00:21:52,580 --> 00:21:59,060
и перенаправлении и паре очень полезных Linux-команд.

