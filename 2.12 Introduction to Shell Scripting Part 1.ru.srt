1
00:00:00,000 --> 00:00:08,000
В этой серии лекций вы узнаете очень важную концепцию — оболочку в Linux.

2
00:00:08,000 --> 00:00:15,000
Вы узнаете, что такое оболочка, что такое bash и какие есть разные реализации программ оболочки.

3
00:00:15,000 --> 00:00:19,000
А в демонстрационной части вы научитесь писать bash-скрипты и запускать их.

4
00:00:19,000 --> 00:00:28,000
Итак, вы освоите основы программирования и написания скриптов на bash, чтобы автоматизировать задачи DevOps.

5
00:00:28,000 --> 00:00:31,000
Мы можем выполнять все эти команды здесь по одной.

6
00:00:31,000 --> 00:00:38,000
Создать пользователя, назначить пользователя в группу, создать папку, создать файл, записать в файл,

7
00:00:38,000 --> 00:00:43,000
изменить разрешения файла, установить программное обеспечение, запустить приложение и т. д.

8
00:00:43,000 --> 00:00:48,000
Все эти команды можно выполнять в интерфейсе командной строки по одной.

9
00:00:48,000 --> 00:00:55,000
Допустим, мы настроили сервер с новым пользователем, а затем установили приложение

10
00:00:55,000 --> 00:01:00,000
и запустили это приложение от имени пользователя, задали все права на файлы и т. д.

11
00:01:00,000 --> 00:01:08,000
А теперь допустим, нам нужно выполнить те же команды в том же порядке на другом сервере, чтобы настроить его так же.

12
00:01:08,000 --> 00:01:14,000
Хотим ли мы выполнять те же команды по одной и на другом сервере?

13
00:01:14,000 --> 00:01:18,000
Допустим, у нас есть 10 серверов, где нужно сделать ровно то же самое.

14
00:01:18,000 --> 00:01:22,000
Так что, хотим ли мы настраивать 10 разных серверов таким образом?

15
00:01:22,000 --> 00:01:28,000
Или что, если вы хотите сохранить историю того, как вы фактически настраивали сервер

16
00:01:28,000 --> 00:01:32,000
или как устанавливали программное обеспечение, если это понадобится позже?

17
00:01:32,000 --> 00:01:36,000
Или, возможно, коллеге это понадобится для его собственного сервера.

18
00:01:36,000 --> 00:01:40,000
Также, что если вам нужна логика при выполнении команд?

19
00:01:40,000 --> 00:01:44,000
Например, сначала вы хотите проверить, существует ли папка или файл,

20
00:01:44,000 --> 00:01:48,000
или хотите проверить, есть ли у пользователя какие-либо права.

21
00:01:48,000 --> 00:01:53,000
Может быть, вы хотите проверить версию программы, установленной в вашей системе, и т. д.

22
00:01:53,000 --> 00:01:55,000
Как насчет массовых действий?

23
00:01:55,000 --> 00:01:59,000
Например, вы хотите переименовать или переместить сразу 100 файлов.

24
00:01:59,000 --> 00:02:03,000
Возможно, вы хотите добавить 10 пользователей в систему и задать им права.

25
00:02:03,000 --> 00:02:07,000
Делать это по одному будет слишком много работы.

26
00:02:07,000 --> 00:02:10,000
И это сделает ваши команды более сложными.

27
00:02:10,000 --> 00:02:16,000
Разве не было бы удобно, если бы мы могли записать эти команды в файл,

28
00:02:16,000 --> 00:02:19,000
вместо того чтобы выполнять их по одной в терминале?

29
00:02:19,000 --> 00:02:21,000
И затем мы можем выполнить этот файл.

30
00:02:21,000 --> 00:02:25,000
Тогда все команды выполнятся по порядку.

31
00:02:25,000 --> 00:02:29,000
Преимущество в том, что теперь вы можете переносить этот файл.

32
00:02:29,000 --> 00:02:34,000
Вы можете скопировать его куда-то еще на другой сервер и выполнить там тоже.

33
00:02:34,000 --> 00:02:39,000
Вы можете поделиться им с товарищами по команде или другими коллегами в компании и т. д.

34
00:02:39,000 --> 00:02:42,000
И вы можете сохранить его где-нибудь для дальнейшего использования.

35
00:02:42,000 --> 00:02:47,000
Так вот, файл с набором команд оболочки называется shell-скриптом.

36
00:02:47,000 --> 00:02:52,000
И вы можете добавлять более сложную логику в команды в shell-скриптах.

37
00:02:52,000 --> 00:02:56,000
Файлы shell-скриптов имеют расширение .sh.

38
00:02:56,000 --> 00:03:00,000
Теперь, говоря о shell-скриптах, что такое оболочка

39
00:03:00,000 --> 00:03:05,000
и почему мы называем файл с набором команд Linux shell-скриптом?

40
00:03:05,000 --> 00:03:10,000
В системах, подобных Unix, включая Linux и macOS,

41
00:03:10,000 --> 00:03:16,000
оболочка — это программа, которая принимает команды, которые вы вводите в интерфейсе командной строки,

42
00:03:16,000 --> 00:03:22,000
и преобразует их в инструкции, понятные ядру вашей операционной системы.

43
00:03:22,000 --> 00:03:28,000
То есть это интерпретатор команд и интерфейс между пользователем и ядром.

44
00:03:28,000 --> 00:03:33,000
Поэтому файл, содержащий набор команд оболочки, которые программа оболочки

45
00:03:33,000 --> 00:03:39,000
может преобразовать в инструкции, понятные ядру, является shell-скриптом.

46
00:03:39,000 --> 00:03:45,000
Существует несколько программ оболочки или разных реализаций программы оболочки.

47
00:03:45,000 --> 00:03:50,000
Есть программа оболочки Bourne с коротким именем sh,

48
00:03:50,000 --> 00:03:57,000
и ее путь в иерархии файловой системы Unix — /bin/sh.

49
00:03:57,000 --> 00:04:01,000
Вот где расположена программа оболочки Bourne,

50
00:04:01,000 --> 00:04:07,000
которая раньше была программой оболочки по умолчанию во многих системах, подобных Unix,

51
00:04:07,000 --> 00:04:11,000
включая многие старые версии дистрибутивов Linux.

52
00:04:11,000 --> 00:04:16,000
Название оболочки Born происходит от её автора, Стефана Борна,

53
00:04:16,000 --> 00:04:20,000
а в более новых версиях дистрибутивов Linux

54
00:04:20,000 --> 00:04:26,000
у нас есть программа оболочки bash, что расшифровывается как born again shell.

55
00:04:26,000 --> 00:04:29,000
Исходя из названия оболочки Born,

56
00:04:29,000 --> 00:04:37,000
потому что bash на самом деле более улучшенная и насыщенная функциями версия sh или born shell.

57
00:04:37,000 --> 00:04:43,000
И, как я уже говорил, bash сейчас является программой оболочки по умолчанию для большинства Unix-подобных систем.

58
00:04:43,000 --> 00:04:49,000
Так что синтаксис команд bash является надмножеством синтаксиса команд born shell или sh.

59
00:04:49,000 --> 00:04:53,000
Существует много других программ оболочек, например Z shell и так далее.

60
00:04:53,000 --> 00:04:59,000
Но, как я уже сказал, bash сейчас, похоже, является стандартом на современных Unix-системах.

61
00:04:59,000 --> 00:05:06,000
И из-за этого термины shell и bash часто используются взаимозаменяемо.

62
00:05:06,000 --> 00:05:12,000
Так что мы говорим о bash-скриптинге и bash-командах вместо shell-скриптинга или shell-команд.

63
00:05:12,000 --> 00:05:17,000
Итак, в одном обобщающем предложении: bash — это программа оболочки,

64
00:05:17,000 --> 00:05:23,000
то есть интерпретатор команд, а также полнофункциональный язык программирования,

65
00:05:23,000 --> 00:05:26,000
с помощью которого мы можем писать shell-скрипты.

66
00:05:26,000 --> 00:05:28,000
Итак, теперь, когда мы это прояснили,

67
00:05:28,000 --> 00:05:37,000
давайте посмотрим, как на самом деле писать shell-скрипты, используя синтаксис bash.

68
00:05:37,000 --> 00:05:42,000
Теперь допустим, мы хотим написать bash-скрипт для настройки сервера.

69
00:05:42,000 --> 00:05:49,000
Давайте создадим файл под названием setup и дадим ему расширение sh.

70
00:05:49,000 --> 00:06:02,000
Это будет наш shell-скрипт setup.sh или bash-скрипт, написанный в синтаксисе bash.

71
00:06:02,000 --> 00:06:07,000
Поскольку все файлы shell-скриптов имеют одинаковое расширение .sh,

72
00:06:07,000 --> 00:06:15,000
как операционная система узнаёт, какую оболочку использовать для интерпретации и обработки этого файла скрипта?

73
00:06:15,000 --> 00:06:20,000
В системе может быть несколько программ оболочек,

74
00:06:20,000 --> 00:06:27,000
и, возможно, мы написали shell-скрипт на sh, или на bash, или, может быть, на Z shell.

75
00:06:27,000 --> 00:06:28,000
Кто знает, да?

76
00:06:28,000 --> 00:06:31,000
Так как же система это узнаёт?

77
00:06:31,000 --> 00:06:39,000
Ну, мы сами говорим системе, какую программу оболочки использовать для интерпретации этого скрипта.

78
00:06:39,000 --> 00:06:40,000
Как?

79
00:06:40,000 --> 00:06:46,000
Написав так называемую строку shebang самой первой строкой скрипта.

80
00:06:46,000 --> 00:06:53,000
Я открою этот файл setup.sh в редакторе vim.

81
00:06:53,000 --> 00:06:58,000
Вы, конечно, можете использовать любой текстовый редактор, любой графический редактор, который захотите,

82
00:06:58,000 --> 00:07:01,000
потому что это просто файл, который можно редактировать.

83
00:07:01,000 --> 00:07:14,000
И первой строкой мы напишем строку shebang, которая говорит операционной системе, что здесь будет синтаксис bash.

84
00:07:14,000 --> 00:07:18,000
Так что, пожалуйста, используйте программу bash для обработки этого файла.

85
00:07:18,000 --> 00:07:22,000
Это объявление синтаксиса, который мы здесь используем.

86
00:07:22,000 --> 00:07:29,000
А этот путь, который вы видите, slash bin slash bash — это фактическое расположение программы bash.

87
00:07:29,000 --> 00:07:39,000
Если я открою новый терминал и выполню ls bin bash, вы увидите, что эта программа находится прямо там.

88
00:07:39,000 --> 00:07:51,000
Или, как мы уже узнавали, можно просто вывести все файлы в slash bin и затем отфильтровать всё, что содержит bash, с помощью команды grep.

89
00:07:51,000 --> 00:07:52,000
Вот и всё.

90
00:07:52,000 --> 00:07:57,000
У нас есть бинарный файл программы bash прямо здесь.

91
00:07:57,000 --> 00:08:00,000
И на него мы ссылаемся в этой строке.

92
00:08:00,000 --> 00:08:10,000
Итак, строка shebang указывает абсолютный путь к интерпретатору вашей оболочки, slash bin slash bash — путь по умолчанию для программы bash.

93
00:08:10,000 --> 00:08:17,000
Если вы используете Windows, например git bash или что-то подобное, путь будет другим.

94
00:08:17,000 --> 00:08:21,000
Теперь вы, вероятно, задаётесь вопросом, почему мы называем это строкой shebang.

95
00:08:21,000 --> 00:08:25,000
И это из-за первых двух символов прямо здесь.

96
00:08:25,000 --> 00:08:34,000
Первый символ — фунт или решётка — также называется sharp, а восклицательный знак — bank.

97
00:08:34,000 --> 00:08:41,000
Так что эти два символа — sharp и bank, а их сокращённое название — shebang.

98
00:08:41,000 --> 00:08:42,000
Вот так.

99
00:08:42,000 --> 00:08:48,000
Используя строку shebang, вы можете решить, какую оболочку хотите использовать.

100
00:08:48,000 --> 00:08:57,000
И, как я упоминал, bash — более функциональная и улучшенная версия born shell или sh.

101
00:08:57,000 --> 00:09:11,000
Однако одно преимущество использования SH, программы оболочки Bourne, в том, что ее можно выполнить на любой Unix-подобной системе, потому что всегда

102
00:09:11,000 --> 00:09:18,000
установлена оболочка Bourne, будь то ранняя или более поздняя версия дистрибутива.

103
00:09:18,000 --> 00:09:28,000
И это, по сути, укажет на программу оболочки Bourne и сообщит операционной системе, что мы используем здесь синтаксис Bourne.

104
00:09:28,000 --> 00:09:31,000
Так что в нашем случае мы собираемся писать скрипт bash.

105
00:09:31,000 --> 00:09:42,000
И это значит, что если вы выполните этот файл позже на сервере, где bash не установлен, то вы получите ошибку, что он недоступен в системе.

106
00:09:42,000 --> 00:09:50,000
И, конечно, вы можете указать любую другую программу оболочки, например dash или zsh и т.д.

107
00:09:50,000 --> 00:09:53,000
Так что это, по сути, первая строка нашего скрипта.

108
00:09:53,000 --> 00:09:58,000
И теперь мы можем записать команды и саму логику здесь.

109
00:10:01,000 --> 00:10:09,000
Теперь давайте напишем базовый скрипт, используя только команду echo, которая выводит все, что мы здесь набираем.

110
00:10:09,000 --> 00:10:16,000
Так что мы выведем setup and configure server.

111
00:10:16,000 --> 00:10:19,000
Это будет наш простой скрипт.

112
00:10:19,000 --> 00:10:26,000
Так что я сохраню это в Vim: Escape, затем двоеточие, записать и выйти.

113
00:10:26,000 --> 00:10:32,000
И теперь у нас есть файл setup.sh, который мы можем выполнить.

114
00:10:32,000 --> 00:10:36,000
Так как же на самом деле выполнять такие shell-скрипты?

115
00:10:36,000 --> 00:10:45,000
На Unix-подобных системах мы можем просто сделать точка, слэш и имя файла вот так.

116
00:10:45,000 --> 00:10:50,000
И это действительно выполнит все команды в этом скрипте.

117
00:10:50,000 --> 00:10:54,000
Однако, если я нажму Enter, вы видите permission denied.

118
00:10:54,000 --> 00:11:01,000
И это потому, что по умолчанию, когда мы создаем новый файл, у нас нет права на его выполнение.

119
00:11:01,000 --> 00:11:05,000
И это то, чему мы научились в лекции о правах пользователей.

120
00:11:05,000 --> 00:11:21,000
Поэтому, если я сделаю длинный вывод с флагом минус L и именем файла, вы видите, что у нас нет права на выполнение для какого-либо владельца файла.

121
00:11:21,000 --> 00:11:28,000
И поскольку я создал файл, по умолчанию мой пользователь является владельцем этого файла.

122
00:11:28,000 --> 00:11:31,000
Однако, как я сказал, у нас нет права на выполнение.

123
00:11:31,000 --> 00:11:35,000
Поэтому перед выполнением нам нужно добавить это право.

124
00:11:35,000 --> 00:11:39,000
Итак, я сделаю sudo для владельца пользователя.

125
00:11:39,000 --> 00:11:42,000
И я могу добавить это право только для моего пользователя.

126
00:11:42,000 --> 00:11:50,000
То есть пользователю добавить право выполнения для setup.sh.

127
00:11:50,000 --> 00:11:55,000
И я забыл здесь указать change mode.

128
00:11:55,000 --> 00:12:05,000
И снова, прежде всего, мы видим X как право выполнения для владельца пользователя.

129
00:12:05,000 --> 00:12:12,000
И также цвет этого файла изменился, потому что теперь это исполняемый файл.

130
00:12:12,000 --> 00:12:19,000
И с этим давайте попробуем снова выполнить скрипт setup.

131
00:12:19,000 --> 00:12:20,000
Вот, пожалуйста.

132
00:12:20,000 --> 00:12:27,000
Это, по сути, просто команда echo, которая выполнилась и вывела все, что мы ввели.

133
00:12:27,000 --> 00:12:32,000
И обратите внимание, что этот способ выполнения shell-скриптов универсален.

134
00:12:32,000 --> 00:12:37,000
Так вы можете выполнить любой shell-скрипт, независимо от того, в каком синтаксисе он написан.

135
00:12:37,000 --> 00:12:44,000
Однако для bash конкретно мы можем также сделать bash, а затем имя файла скрипта.

136
00:12:44,000 --> 00:12:45,000
Вот, пожалуйста.

137
00:12:45,000 --> 00:12:47,000
Это тоже работает.

