1
00:00:00,000 --> 00:00:13,200
Теперь давайте снова откроем этот файл и посмотрим ещё на немного более интересный синтаксис.

2
00:00:13,200 --> 00:00:19,200
Прежде всего, у нас есть очень важное понятие переменных в скриптах для хранения значения

3
00:00:19,200 --> 00:00:23,360
один раз, а затем многократно ссылаться на него по всему скрипту.

4
00:00:23,360 --> 00:00:29,560
Например, у нас может быть определённый файл, который нужен во многих разных командах.

5
00:00:29,560 --> 00:00:36,280
Поэтому мы можем один раз сохранить имя этого файла в переменную под названием file name, которую мы можем

6
00:00:36,280 --> 00:00:42,400
записать либо с подчёркиванием, как file underscore name, либо мы можем также использовать

7
00:00:42,400 --> 00:00:47,600
так называемый camel case, как здесь; я буду использовать синтаксис с подчёркиванием.

8
00:00:47,600 --> 00:00:52,240
И это лишь стандарты — называть переменные можно как угодно.

9
00:00:52,240 --> 00:00:59,880
И мы можем присвоить значение этой переменной, используя знак равенства, а затем само значение.

10
00:00:59,880 --> 00:01:05,640
И допустим, этот файл — config.yaml, это не так важно.

11
00:01:05,640 --> 00:01:06,640
Это наш файл.

12
00:01:06,640 --> 00:01:12,680
Затем мы можем использовать эту переменную во всех командах, где хотим ссылаться на этот

13
00:01:12,680 --> 00:01:13,680
файл.

14
00:01:13,680 --> 00:01:18,800
Теперь, как нам ссылаться на переменные, созданные в скрипте? Снова используя

15
00:01:18,800 --> 00:01:27,960
команду echo, мы можем сказать using file, а затем поставить доллар и имя переменной

16
00:01:27,960 --> 00:01:36,980
вот так: using file имя файла для настройки чего-то — не так важно.

17
00:01:36,980 --> 00:01:45,680
Так что это, по сути, синтаксис использования/ссылки на переменные в скрипте.

18
00:01:45,680 --> 00:01:51,960
Ещё одна классная вещь про переменные: им можно присваивать значения,

19
00:01:51,960 --> 00:01:55,320
которые являются выводом выполнения команды.

20
00:01:55,320 --> 00:02:02,560
Например, если я делаю ls и хочу вывести всё содержимое папки

21
00:02:02,560 --> 00:02:09,000
под названием config, я могу сохранить результат выполнения этой команды в переменную

22
00:02:09,000 --> 00:02:13,600
и затем многократно ссылаться на него в скрипте, где нужно.

23
00:02:13,600 --> 00:02:21,920
Чтобы это сделать, синтаксис такой: доллар, затем оборачиваем команду в скобки,

24
00:02:21,920 --> 00:02:23,960
и затем присваиваем это переменной.

25
00:02:23,960 --> 00:02:31,760
И допустим, это config files, или все конфигурационные файлы, которые нам нужны.

26
00:02:31,760 --> 00:02:43,880
И снова, чтобы сослаться на эту переменную, давайте сделаем ещё один echo: contents of config folder,

27
00:02:43,880 --> 00:03:01,200
или можно написать here are all configuration files и использовать здесь переменную config files.

28
00:03:01,200 --> 00:03:09,000
И снова, давайте это сохраним и попробуем выполнить, хотя у нас нет папки config

29
00:03:09,000 --> 00:03:12,760
здесь.

30
00:03:12,760 --> 00:03:18,240
И посмотрим, что произойдёт.

31
00:03:18,240 --> 00:03:24,040
Сначала мы видим нашу команду echo, затем получаем cannot access config, no such file or

32
00:03:24,040 --> 00:03:26,680
directory — то же самое и здесь.

33
00:03:26,680 --> 00:03:30,880
Это имя файла, которое мы использовали в команде echo.

34
00:03:30,880 --> 00:03:35,400
И это, по сути, ещё одна команда echo, которая ничего не показывает, потому что у нас нет

35
00:03:35,400 --> 00:03:45,920
config, потому что команда ls config здесь, по сути, вернула ничего, пустой результат.

36
00:03:45,920 --> 00:03:47,800
И вот что мы имеем в итоге.

37
00:03:47,800 --> 00:03:50,840
То есть по сути у нас есть ошибка при выполнении.

38
00:03:50,840 --> 00:03:56,440
И это может происходить довольно часто, потому что мы не всегда контролируем окружение.

39
00:03:57,440 --> 00:04:07,220
Поэтому очень полезное понятие, которое мы используем в скриптах, называется условными конструкциями.

40
00:04:07,220 --> 00:04:12,680
Поэтому перед выполнением некоторых команд, насчёт которых мы не уверены, что они пройдут успешно,

41
00:04:12,680 --> 00:04:19,360
мы сначала проверяем, существует ли папка config, прежде чем выполнять

42
00:04:19,360 --> 00:04:25,520
ls config, например, или прежде чем пытаться открыть, выполнить или сделать что-то с файлом

43
00:04:25,600 --> 00:04:30,080
вроде config.yaml, мы проверяем, существует ли этот файл на системе.

44
00:04:30,080 --> 00:04:35,180
И если нет, возможно, создаём папку или файл, или делаем что-то другое.

45
00:04:35,180 --> 00:04:39,900
Давайте посмотрим, как это работает.

46
00:04:39,900 --> 00:04:48,040
Итак, прямо здесь, перед созданием переменной с выполнением команды ls config, мы собираемся

47
00:04:48,040 --> 00:04:54,600
добавить эту условную конструкцию, и синтаксис для этого — if, это ключевое слово, которое позволяет

48
00:04:54,680 --> 00:05:00,840
задать условие, например, существует ли папка config в системе.

49
00:05:00,840 --> 00:05:06,480
И это условие помещается между квадратными скобками вот так.

50
00:05:06,480 --> 00:05:12,800
И здесь мы можем написать config и проверить, является ли этот config каталогом или нет,

51
00:05:12,800 --> 00:05:20,000
мы можем использовать минус D. И это выражение здесь в квадратных скобках в основном называется

52
00:05:20,000 --> 00:05:24,760
условием, и оно проверяет, является ли config каталогом или нет.

53
00:05:24,760 --> 00:05:31,920
Так что если это верно, если config — каталог, тогда идет другое ключевое слово.

54
00:05:31,920 --> 00:05:38,360
Тогда мы выполняем все, что идет после then, если это условие истинно.

55
00:05:38,360 --> 00:05:51,200
Мы можем сделать echo config или читать содержимое каталога config.

56
00:05:51,200 --> 00:05:57,240
И мы можем добавить логику того, что делать, если каталога config нет.

57
00:05:57,240 --> 00:06:04,360
Для этого снова используем else, сделаем пару echo, это по сути эхо

58
00:06:04,360 --> 00:06:07,880
это просто сообщения или информация для вас.

59
00:06:07,880 --> 00:06:12,760
При выполнении скрипта для исполнения команд это на самом деле не нужно.

60
00:06:12,760 --> 00:06:14,200
Это просто добавляет больше информации.

61
00:06:14,200 --> 00:06:19,400
Допустим, если каталог config не найден, тогда выведем сообщение, что

62
00:06:19,400 --> 00:06:31,440
config, не найден, создаем его.

63
00:06:31,440 --> 00:06:34,920
Затем фактически создадим каталог с именем config.

64
00:06:34,920 --> 00:06:44,080
И вы уже знаете команду для этого — make directory, mkdir и config.

65
00:06:44,080 --> 00:06:51,800
Когда мы закончили с нашей условной логикой, также называемой оператором if else, потому что мы

66
00:06:51,800 --> 00:06:55,760
имеем здесь условия if и else.

67
00:06:55,760 --> 00:07:02,080
И когда мы закончили, мы говорим программе, что все, набирая здесь fi, что

68
00:07:02,080 --> 00:07:06,680
по сути обратное от if — это просто синтаксис.

69
00:07:06,680 --> 00:07:11,960
И программа поймет, где начало, а где конец этой логики.

70
00:07:11,960 --> 00:07:18,520
Итак, снова recap: когда мы хотим проверить какую-то логику, проверить условие, мы можем написать

71
00:07:18,520 --> 00:07:23,720
эти конструкции if else, где мы проверяем, если что-то истина, тогда выполняем определенную

72
00:07:23,720 --> 00:07:25,080
логику, иначе.

73
00:07:25,080 --> 00:07:29,120
То есть, если это неверно, мы выполняем другую логику.

74
00:07:29,120 --> 00:07:33,680
И это позволяет нам готовиться к разным сценариям.

75
00:07:33,680 --> 00:07:39,320
Давайте сохраним и выполним.

76
00:07:39,320 --> 00:07:40,320
Ну вот.

77
00:07:40,320 --> 00:07:45,680
У нас есть первый echo и сообщение config dir not found creating one.

78
00:07:45,680 --> 00:07:48,720
А затем у нас два финальных echo.

79
00:07:48,720 --> 00:07:58,520
И если я сделаю ls config, прямо здесь у нас каталог config, который создал наш скрипт.

80
00:07:58,520 --> 00:08:06,800
Теперь, если запустим снова, вместо config dir not found у нас 'reading config directory'

81
00:08:06,800 --> 00:08:07,960
содержимого.

82
00:08:07,960 --> 00:08:15,180
То есть в первый раз, когда мы запускали скрипт, каталога config не было.

83
00:08:15,180 --> 00:08:20,960
Так что это условие было неверным.

84
00:08:20,960 --> 00:08:23,920
Поэтому выполнился блок else.

85
00:08:23,920 --> 00:08:29,440
Во второй раз, когда каталог config уже был создан, это было истинно, или это условие

86
00:08:29,440 --> 00:08:30,840
действительно было истинным.

87
00:08:30,840 --> 00:08:33,880
Поэтому был выполнен блок then.

88
00:08:33,880 --> 00:08:40,960
Так работают условные конструкции и операторы if else.

89
00:08:40,960 --> 00:08:46,000
То, что мы здесь видели, также называется файловыми условиями.

90
00:08:46,000 --> 00:08:53,040
Это набор условий, которые можно применять к типам файлов.

91
00:08:53,040 --> 00:08:59,200
Например, проверять, является ли указанное здесь имя каталогом.

92
00:08:59,200 --> 00:09:05,760
Мы также можем проверить, является ли указанное имя файлом.

93
00:09:05,760 --> 00:09:12,680
Если мы возьмем config.yaml, например, можем проверить, есть ли файл с таким именем.

94
00:09:12,680 --> 00:09:17,600
Помимо проверки существования файла или каталога, можно проверять права на

95
00:09:17,600 --> 00:09:19,600
файл или каталог.

96
00:09:19,600 --> 00:09:26,480
Мы можем проверить, читаем ли файл, доступен ли для записи или выполнения.

97
00:09:26,480 --> 00:09:32,720
Мы также можем проверить, пуст ли файл или внутри что-то есть.

98
00:09:32,720 --> 00:09:38,240
Например, проверять, ненулевой ли размер с помощью флага -s.

99
00:09:38,240 --> 00:09:43,840
И можно посмотреть, установлен ли на файл user ID или group ID.

100
00:09:43,840 --> 00:09:50,720
И снова, эти условия очень полезны, когда мы точно не знаем окружение

101
00:09:50,720 --> 00:09:53,760
где мы выполняем наш скрипт.

102
00:09:53,760 --> 00:09:59,880
И мы хотим проверить, пуст ли файл, прежде чем, возможно, что-то там перезаписать.

103
00:09:59,880 --> 00:10:10,000
Помимо условий для файлов, у нас есть сравнения чисел.

104
00:10:10,000 --> 00:10:15,280
Например, если у меня здесь есть переменная, это может быть количество файлов, количество процессов

105
00:10:15,280 --> 00:10:18,320
работающих, может быть размер файла.

106
00:10:18,320 --> 00:10:21,040
То есть все, что можно представить как число.

107
00:10:21,040 --> 00:10:26,880
В нашем случае, скажем, у нас есть количество файлов, которое задается извне.

108
00:10:26,880 --> 00:10:32,360
То есть это какое-то неизвестное значение, которое мы позже можем настроить для скрипта.

109
00:10:32,360 --> 00:10:38,480
И поскольку мы не знаем фактическое значение, мы можем проверить его в выражении if.

110
00:10:38,480 --> 00:10:48,880
То есть можем сказать: если количество файлов равно 10, например, можно выполнить какую-то логику здесь.

111
00:10:48,880 --> 00:10:56,860
Мы также можем проверить, меньше ли оно 10, с LT.

112
00:10:56,860 --> 00:11:02,880
Например, если количество файлов меньше 10, мы можем выполнить их за один заход.

113
00:11:02,880 --> 00:11:06,380
Мы также можем проверить, больше ли оно 10.

114
00:11:06,380 --> 00:11:10,880
Может быть, мы решим, что файлов слишком много, и не захотим перегружать систему.

115
00:11:10,880 --> 00:11:17,840
У нас есть также больше или равно с GE или меньше или равно.

116
00:11:17,840 --> 00:11:20,240
И, наконец, есть не равно.

117
00:11:20,240 --> 00:11:25,720
Снова, с числовыми сравнениями можно делать много полезных проверок.

118
00:11:25,720 --> 00:11:31,480
Например, можно проверить, равен ли порт, на котором работает приложение,

119
00:11:31,480 --> 00:11:38,880
конкретному значению, или, возможно, количество работающих процессов выше допустимого значения или

120
00:11:38,880 --> 00:11:39,880
что угодно.

121
00:11:39,880 --> 00:11:42,880
Итак, у нас есть условия для файлов, у нас есть числовые сравнения.

122
00:11:42,880 --> 00:11:49,760
У нас также есть сравнения строк, где мы просто сравниваем набор символов,

123
00:11:49,760 --> 00:11:50,760
строки.

124
00:11:50,760 --> 00:11:55,520
Опять же, допустим, это переменная, которая передается извне, и допустим, это

125
00:11:55,520 --> 00:12:05,440
группа или пользовательская группа с некоторым значением, которое мы можем задать при выполнении скрипта.

126
00:12:05,440 --> 00:12:11,120
И здесь в условии if мы можем фактически проверить значение этой строки.

127
00:12:11,120 --> 00:12:18,920
То есть можем сказать: если user group равна, и мы делаем сравнение либо одним знаком равенства

128
00:12:18,920 --> 00:12:23,200
либо двойным знаком равенства вот так, в чем разница?

129
00:12:23,200 --> 00:12:29,680
Двойное равенство специфично для bash, а один знак равенства — POSIX-стандарт, что

130
00:12:29,680 --> 00:12:34,740
значит, что он кросс-совместим для всех программ оболочки.

131
00:12:34,740 --> 00:12:46,940
Итак, если user group равна Nana, это имя группы пользователя для моего пользователя, тогда я выполню какую-то

132
00:12:46,940 --> 00:12:53,340
логику здесь, настроим сервер, и дальше else.

133
00:12:53,340 --> 00:13:03,860
То есть если user group не Nana, то, возможно, мы выведем что-то вроде нет разрешения на настройку

134
00:13:04,860 --> 00:13:17,420
сервера, неверная группа пользователя и закончим выражение if с fi.

135
00:13:17,420 --> 00:13:22,700
То есть мы можем сравнивать две строки друг с другом, используя эти двойные знаки равенства.

136
00:13:22,700 --> 00:13:25,980
Теперь что, если мы хотим проверить два разных значения?

137
00:13:25,980 --> 00:13:30,420
Сначала мы хотим проверить, является ли user group Nana, если нет, то хотим проверить другое

138
00:13:30,420 --> 00:13:33,620
значение, например user group равна admin.

139
00:13:33,620 --> 00:13:39,780
И если оба из них не true, тогда мы хотим выполнить этот блок вот здесь.

140
00:13:39,780 --> 00:13:41,380
Так как же это сделать?

141
00:13:41,380 --> 00:13:50,060
Между if и else у нас есть еще оператор под названием else if, который сокращенно пишется

142
00:13:50,060 --> 00:13:58,340
elif, и у него есть собственное условие, где мы можем снова проверить другое значение

143
00:13:58,340 --> 00:13:59,460
вот так.

144
00:13:59,460 --> 00:14:07,200
То есть если user group — Nana, тогда делаем это, else if, если это не true, тогда проверяем, является ли

145
00:14:07,200 --> 00:14:09,300
user group admin.

146
00:14:09,300 --> 00:14:22,060
Если да, то выполняем другую логику, например администрируем сервер, что угодно.

147
00:14:22,060 --> 00:14:29,060
И если оба из этих не true, то есть user group ни Nana, ни admin.

148
00:14:29,540 --> 00:14:33,740
Тогда мы выполняем другую логику в else.

149
00:14:33,740 --> 00:14:40,020
И, конечно, эта логика относится не только к строкам, но к любым типам условий.

150
00:14:40,020 --> 00:14:44,220
Это базовый if else, if else оператор.

151
00:14:44,220 --> 00:14:53,300
И наконец, для строк вы также можете проверить, содержит ли эта строка подстроку.

152
00:14:53,300 --> 00:14:56,820
И мы также можем проверить, является ли строка пустой или нет.

153
00:14:56,820 --> 00:15:00,820
Итак, это по сути условные конструкции и то, как вы можете использовать их с числами, строками или

154
00:15:00,820 --> 00:15:09,780
файлами, чтобы проверять определенные условия и задавать определенную логику в своем скрипте в зависимости от того,

155
00:15:09,780 --> 00:15:11,900
каковы эти условия.

156
00:15:11,900 --> 00:15:20,220
Теперь, в этих примерах, я упомянул, что могут быть какие-то значения, которые настраиваются

157
00:15:20,220 --> 00:15:25,740
снаружи, когда мы запускаем скрипт, мы можем, по сути, передавать их как параметры

158
00:15:25,740 --> 00:15:28,620
или настраивать их снаружи.

159
00:15:28,620 --> 00:15:30,660
Итак, как это вообще работает?

160
00:15:30,660 --> 00:15:38,540
Как мы можем предоставлять значения извне нашему скрипту, которые мы затем можем читать внутри скрипта

161
00:15:38,540 --> 00:15:45,340
или ссылаться на них, проверяя их значение и делая какие-то условные проверки и т.д.

162
00:15:45,340 --> 00:15:52,460
И это еще одна концепция в bash-скриптинге, а именно вы можете фактически передавать параметры

163
00:15:52,460 --> 00:15:55,580
в свой скрипт, когда вы его выполняете.

164
00:15:55,580 --> 00:16:00,660
Допустим, мы хотим передать группу пользователей как параметр и хотим прочитать этот параметр

165
00:16:00,660 --> 00:16:01,980
здесь.

166
00:16:01,980 --> 00:16:09,100
Чтобы прочитать параметр, который передан при выполнении bash-скрипта, у нас есть специальная переменная,

167
00:16:09,100 --> 00:16:15,180
к которой мы можем обратиться, используя синтаксис, помните, синтаксис обращения к любой переменной — знак доллара

168
00:16:15,180 --> 00:16:19,780
вот здесь или в тех командах echo.

169
00:16:19,780 --> 00:16:24,060
А затем после знака доллара у нас идет единица.

170
00:16:24,060 --> 00:16:29,660
Так что это будет первый параметр, который мы передаем в bash-скрипт.

171
00:16:29,660 --> 00:16:39,300
И если я сохраню это и выполню bash-скрипт, не передавая сначала параметр, у нас будет

172
00:16:39,300 --> 00:16:50,540
строка echo, которая говорит "нет разрешения на настройку сервера", потому что мы не передали никакого параметра.

173
00:16:50,540 --> 00:16:53,460
И здесь по сути было просто пусто, верно?

174
00:16:53,460 --> 00:16:55,580
Здесь не было значения.

175
00:16:55,580 --> 00:16:59,660
Поэтому оба эти оператора if оказались ложными.

176
00:16:59,660 --> 00:17:02,580
Поэтому был выполнен блок else.

177
00:17:02,580 --> 00:17:11,060
И для лучшего отображения давайте вообще-то разделим вывод.

178
00:17:11,060 --> 00:17:16,020
А теперь давайте выполним наш скрипт с параметром.

179
00:17:16,020 --> 00:17:19,100
И я собираюсь передать admin.

180
00:17:19,100 --> 00:17:31,100
И я на самом деле забыл сослаться на эту переменную здесь со знаком доллара в кавычках вот так.

181
00:17:31,100 --> 00:17:39,180
Итак, по сути, мы присваиваем переменную параметра, которую получаем извне, переменной

182
00:17:39,180 --> 00:17:40,180
user group.

183
00:17:40,180 --> 00:17:44,100
И затем мы используем эту переменную user group, чтобы проверить ее значение.

184
00:17:44,100 --> 00:17:47,940
Давайте снова попробуем с группой admin.

185
00:17:47,940 --> 00:17:48,940
И вот, пожалуйста.

186
00:17:48,940 --> 00:17:54,700
У нас есть вывод, что сервер администрируется, когда имя группы — admin.

187
00:17:54,700 --> 00:18:02,660
И здесь также есть еще одна задача, в которой говорится настроить сервер.

188
00:18:02,660 --> 00:18:09,380
Так вот как вы можете принимать параметры извне в свой bash-скрипт.

189
00:18:09,380 --> 00:18:15,940
А затем вы можете использовать ссылки на эти параметры, сначала присвоив их переменной, а

190
00:18:15,940 --> 00:18:18,220
затем обращаясь к этой переменной.

191
00:18:18,220 --> 00:18:27,020
Мы также можем передавать несколько параметров нашему bash-скрипту, чтобы сделать его еще более настраиваемым.

192
00:18:27,020 --> 00:18:33,020
Например, допустим, мы хотим передать имя этого каталога как параметр вместо

193
00:18:33,020 --> 00:18:35,900
жесткой прописки его в скрипте.

194
00:18:35,900 --> 00:18:45,660
Итак, допустим, имя переменной каталога config равно давайте сделаем это первым

195
00:18:45,660 --> 00:18:49,060
параметром, а это вторым.

196
00:18:49,060 --> 00:18:54,580
Таким образом, какой бы параметр мы ни передали, его значение будет присвоено переменной config dir,

197
00:18:54,580 --> 00:18:58,740
а второй параметр будет присвоен переменной, называемой user group.

198
00:18:58,740 --> 00:19:03,660
И теперь мы можем использовать это значение config dir в нашем скрипте.

199
00:19:03,660 --> 00:19:07,980
Так что допустим, мы хотим заменить эту строку здесь.

200
00:19:07,980 --> 00:19:13,620
И снова двойные кавычки, знак доллара, имя переменной.

201
00:19:13,620 --> 00:19:21,980
Мы проверяем, существует ли в системе директория с именем, переданным параметром.

202
00:19:21,980 --> 00:19:32,140
И если существует

203
00:19:32,140 --> 00:19:35,700
мы выводим содержимое этой папки.

204
00:19:35,700 --> 00:19:43,100
И здесь снова создаём папку с этим переданным именем.

205
00:19:43,900 --> 00:19:49,180
Чтобы при выводе содержимого было что показать, давайте также создадим файл

206
00:19:49,180 --> 00:20:09,660
внутри директории, назовём его config.sh, и запустим.

207
00:20:09,660 --> 00:20:13,980
Давайте дадим ей другое имя, потому что папка config уже есть.

208
00:20:13,980 --> 00:20:19,700
Назовём её setup-scripts.

209
00:20:19,700 --> 00:20:22,140
И затем у нас есть имя группы.

210
00:20:22,140 --> 00:20:24,940
Назовём её admin и запустим.

211
00:20:24,940 --> 00:20:28,660
Сначала получаем: config dir not found, создаём её.

212
00:20:28,660 --> 00:20:31,140
И запускаем ещё раз.

213
00:20:31,140 --> 00:20:32,140
Вот и всё.

214
00:20:32,140 --> 00:20:34,500
Читаем содержимое директории config.

215
00:20:34,500 --> 00:20:44,700
И вот здесь у нас все конфигурационные файлы, config.sh.

216
00:20:44,700 --> 00:20:55,980
Итак, ещё раз: мы передали скрипту два параметра, просто перечислив их, разделёнными

217
00:20:55,980 --> 00:20:58,260
пробелом, один за другим.

218
00:20:58,260 --> 00:21:03,260
Таким образом можно передавать ещё больше параметров, все через пробел.

219
00:21:03,260 --> 00:21:11,700
Затем мы можем читать каждый параметр, используя доллар и цифру от одного до девяти.

220
00:21:11,700 --> 00:21:15,540
То есть это первый параметр, это второй параметр и так далее.

221
00:21:15,540 --> 00:21:20,380
Значение, которое хранится в параметре, мы можем присвоить переменной и затем

222
00:21:20,380 --> 00:21:28,660
использовать и ссылаться на эту переменную по всему скрипту, как делаем здесь.

223
00:21:28,660 --> 00:21:34,860
Синтаксис обращения к переменным, как вы видели, это доллар и имя переменной,

224
00:21:34,860 --> 00:21:37,420
заключённые в двойные кавычки.

225
00:21:37,420 --> 00:21:43,980
Это по сути говорит нашей программе bash, что мы читаем значение переменной.

226
00:21:43,980 --> 00:21:51,580
И мы можем использовать это в условиях и разных командах shell, как здесь.

227
00:21:51,580 --> 00:21:57,360
В нашем случае мы передаём имя директории config как параметр.

228
00:21:57,360 --> 00:21:59,920
Мы проверяем, существует ли эта директория.

229
00:21:59,920 --> 00:22:05,920
Если да, то по сути читаем содержимое директории и сохраняем его

230
00:22:05,920 --> 00:22:13,480
в переменную config_files, которую потом можем использовать далее в скрипте, что

231
00:22:13,480 --> 00:22:16,560
как раз и делаем здесь.

232
00:22:16,560 --> 00:22:24,640
И это по сути синтаксис выполнения команды ls с переменной в качестве ссылки,

233
00:22:24,640 --> 00:22:26,880
после чего мы сохраняем её вывод.

234
00:22:26,880 --> 00:22:33,440
Главное преимущество параметров, которые можно передавать bash-скрипту, в том, что

235
00:22:33,440 --> 00:22:36,160
скрипт становится настраиваемым.

236
00:22:36,160 --> 00:22:40,480
Вместо того чтобы жёстко прописывать все значения, мы можем динамически задавать

237
00:22:40,480 --> 00:22:44,460
разные значения, которые не хотим жёстко фиксировать, верно?

238
00:22:44,460 --> 00:22:50,200
Например, мы хотим, чтобы версия устанавливаемого приложения задавалась параметром.

239
00:22:50,200 --> 00:22:55,620
Или чтобы имя пользователя Linux, которого создаём скриптом, можно было настроить.

240
00:22:55,620 --> 00:22:59,980
Так пользователь скрипта сам решает, как назвать

241
00:22:59,980 --> 00:23:03,980
пользователя или группу и т. д.

242
00:23:03,980 --> 00:23:09,780
Параметризация bash-скрипта очень мощная, потому что позволяет написать

243
00:23:09,780 --> 00:23:19,500
скрипт один раз и использовать его в разных сценариях, передавая разные параметры.

244
00:23:19,500 --> 00:23:26,660
Есть и второй способ передавать значения в ваш bash-скрипт или задавать значения

245
00:23:26,660 --> 00:23:29,100
для него извне.

246
00:23:29,100 --> 00:23:34,700
И это чтение, явное чтение пользовательского ввода.

247
00:23:34,700 --> 00:23:40,380
Давайте уберём все эти строки и начнём с чистого листа.

248
00:23:40,380 --> 00:23:47,100
Как мы видели в учебнике по теме, можно перейти в командный режим и сделать dd,

249
00:23:47,100 --> 00:23:54,140
и это будет удалять строки одну за другой, либо сделать d и затем число

250
00:23:54,140 --> 00:23:59,740
строк, которые хотим удалить, например 10, и снова d.

251
00:23:59,740 --> 00:24:04,740
И это по сути удалит десять или больше строк.

252
00:24:04,740 --> 00:24:15,260
Теперь давайте посмотрим: мы хотим попросить того, кто запускает bash-скрипт, ввести данные, потому что

253
00:24:15,500 --> 00:24:20,220
возможно, они не знают, что bash-скрипт вообще ожидает параметры, или, может быть,

254
00:24:20,220 --> 00:24:26,700
есть какие-то конфиденциальные данные, которые они не хотят передавать как параметр, но мы хотим

255
00:24:26,700 --> 00:24:29,340
прочитать их явно из командной строки.

256
00:24:29,340 --> 00:24:31,260
Посмотрим, как это работает.

257
00:24:31,260 --> 00:24:37,500
Давайте напишем echo чтение пользовательского ввода.

258
00:24:37,740 --> 00:24:47,740
Способ прочитать ввод пользователя в нашем скрипте — использовать read и затем промпт с минус p.

259
00:24:47,740 --> 00:24:50,940
И этот промпт — по сути то, что мы показываем пользователю.

260
00:24:50,940 --> 00:24:55,580
То есть мы говорим: пожалуйста, введите ваш пароль.

261
00:24:57,900 --> 00:24:59,180
Это и есть подсказка.

262
00:24:59,900 --> 00:25:06,060
И дальше, очевидно, мы хотим сохранить всё, что ввёл пользователь, в переменную.

263
00:25:06,060 --> 00:25:11,260
В случае параметров у нас параметры автоматически сохранялись в переменную с именем

264
00:25:11,260 --> 00:25:13,020
один, два и так далее.

265
00:25:13,020 --> 00:25:17,180
Так что мы можем ссылаться на них, используя доллар один, доллар два и так далее.

266
00:25:17,180 --> 00:25:24,060
Здесь нам на самом деле нужно явно назвать переменную, которая будет хранить пользовательский ввод.

267
00:25:24,620 --> 00:25:26,300
И мы можем назвать её как угодно.

268
00:25:26,940 --> 00:25:32,140
В нашем случае я собираюсь сделать user password вот так.

269
00:25:33,100 --> 00:25:39,100
И, разумеется, вы можете использовать пароль, чтобы аутентифицировать пользователя или делать что угодно,

270
00:25:39,100 --> 00:25:42,940
сделать какие-то вызовы к сервису с их паролем.

271
00:25:42,940 --> 00:25:45,340
В нашем случае мы просто собираемся вывести его.

272
00:25:45,340 --> 00:25:48,940
Очевидно, это небезопасно, но это лишь пример.

273
00:25:48,940 --> 00:25:50,940
Так что мы выведем пароль обратно.

274
00:25:51,740 --> 00:25:54,380
Спасибо за ваш пароль.

275
00:25:55,180 --> 00:26:01,580
И затем само значение пароля.

276
00:26:01,660 --> 00:26:03,500
А теперь давайте это выполнем

277
00:26:12,460 --> 00:26:13,500
без параметров.

278
00:26:14,380 --> 00:26:15,100
И вот, пожалуйста.

279
00:26:15,100 --> 00:26:17,660
У нас есть echo чтение пользовательского ввода.

280
00:26:17,660 --> 00:26:20,220
И затем у нас есть подсказка.

281
00:26:20,220 --> 00:26:25,740
Вы видите этот мигающий курсор, который ждёт нашего ввода.

282
00:26:25,740 --> 00:26:27,500
Пожалуйста, введите ваш пароль.

283
00:26:27,500 --> 00:26:33,500
Скажем, это мой пароль, и он просто выводит его обратно мне.

284
00:26:35,900 --> 00:26:44,700
Итак, используя read и подсказку, мы можем по сути попросить любое количество пользовательского ввода,

285
00:26:44,700 --> 00:26:46,380
которое нам может понадобиться в нашем bash-скрипте.

286
00:26:47,260 --> 00:26:53,740
Теперь, возвращаясь к концепции параметров для передачи значений в наш shell-скрипт,

287
00:26:53,740 --> 00:26:58,220
что, если мы не знаем, сколько параметров предоставит пользователь?

288
00:26:58,220 --> 00:27:02,460
Или что, если мы просто хотим принимать любое количество параметров,

289
00:27:02,460 --> 00:27:06,940
не указывая точно, сколько их должно быть?

290
00:27:06,940 --> 00:27:11,820
Так как же узнать, сколько параметров пользователь на самом деле передал нашему скрипту?

291
00:27:11,820 --> 00:27:17,260
И чтобы показать это как пример, давайте сделаем echo user.

292
00:27:18,060 --> 00:27:25,820
А затем первый параметр, затем у нас есть group и второй параметр.

293
00:27:29,020 --> 00:27:29,660
И всё.

294
00:27:31,260 --> 00:27:33,340
А теперь, когда мы выполняем,

295
00:27:36,700 --> 00:27:39,100
давайте сделаем user и group.

296
00:27:39,100 --> 00:27:43,100
И добавим здесь ещё один параметр, например finally.

297
00:27:47,580 --> 00:27:53,100
И давайте также укажем имя каталога для расположения всех скриптов,

298
00:27:54,140 --> 00:27:54,780
вот так.

299
00:27:54,780 --> 00:27:58,860
И если я выполню, вы увидите, что первые два параметра были прочитаны,

300
00:27:58,860 --> 00:28:01,100
вполне нормально, потому что именно это принимал наш скрипт.

301
00:28:02,300 --> 00:28:04,060
Пользователь и группа.

302
00:28:04,620 --> 00:28:07,580
Однако остальные параметры были проигнорированы.

303
00:28:07,580 --> 00:28:11,740
Так как же нам переписать наш скрипт так, чтобы он мог принимать

304
00:28:11,740 --> 00:28:16,380
и действительно читать все параметры, которые предоставляет пользователь?

305
00:28:17,260 --> 00:28:26,540
Прежде всего, у нас есть ещё одна специальная переменная, которая читает или по сути хранит значения

306
00:28:26,540 --> 00:28:30,220
всех параметров, переданных скрипту.

307
00:28:30,220 --> 00:28:39,420
Так что прямо здесь я сделаю all params и затем знак доллара и вот эту звёздочку

308
00:28:40,060 --> 00:28:40,860
здесь.

309
00:28:41,980 --> 00:28:45,020
И если я сохраню это и выполню снова,

310
00:28:45,660 --> 00:28:52,300
вы видите, что специальная переменная доллар и звёздочка действительно выводит

311
00:28:53,020 --> 00:28:55,580
все параметры, которые мы предоставили.

312
00:28:55,580 --> 00:29:01,580
Так что у нас есть переменная, которая даёт нам доступ ко всем переданным параметрам.

313
00:29:02,220 --> 00:29:05,260
И не важно, сколько параметров мы передаём сюда,

314
00:29:07,340 --> 00:29:10,780
все они будут в этой специальной переменной.

315
00:29:11,580 --> 00:29:20,060
У нас также есть ещё одна специальная переменная, которая даёт нам количество переданных параметров.

316
00:29:26,220 --> 00:29:29,100
И это знак доллара и решётка.

317
00:29:33,420 --> 00:29:35,900
И давайте проверим это снова.

318
00:29:35,900 --> 00:29:40,620
Итак, у нас пять параметров и фактические значения этих параметров.

319
00:29:41,660 --> 00:29:52,300
Теперь, как на самом деле читать все эти отдельные параметры один за другим в нашей программе BASH?

320
00:29:52,300 --> 00:29:59,100
Всякий раз, когда у нас есть список, с которым мы работаем, список чисел, список символов,

321
00:29:59,100 --> 00:30:06,940
список строк, список файлов, как угодно назовите, мы работаем с концепцией, называемой циклами.

322
00:30:07,580 --> 00:30:15,420
Так что цикл — это, по сути, программа, которая запускается снова и снова и выполняет конкретную логику

323
00:30:15,420 --> 00:30:18,700
для каждого отдельного элемента в списке.

324
00:30:19,660 --> 00:30:25,980
Так что в нашем примере, допустим, давайте вообще уберём это тоже.

325
00:30:27,020 --> 00:30:32,140
И скажем, мы хотим пройтись по всем значениям, которые у нас есть как параметры,

326
00:30:32,140 --> 00:30:33,980
что бы ни предоставил пользователь, мы не знаем.

327
00:30:34,620 --> 00:30:39,820
И мы хотим выполнить конкретную логику для этих параметров.

328
00:30:39,820 --> 00:30:45,660
И чтобы читать эти значения параметров по одному из списка параметров,

329
00:30:45,660 --> 00:30:48,620
мы будем использовать то, что называется циклом for.

330
00:30:48,620 --> 00:30:51,020
И синтаксис для этого — for.

331
00:30:51,020 --> 00:30:55,900
А затем мы ссылаемся на отдельное значение в списке по имени,

332
00:30:55,900 --> 00:30:58,060
которое мы можем назвать как угодно.

333
00:30:58,060 --> 00:31:05,420
Допустим, param или отдельный параметр, что угодно, после in.

334
00:31:05,420 --> 00:31:11,020
И теперь у нас есть список параметров, по которым мы хотим пройтись один за другим.

335
00:31:12,540 --> 00:31:15,900
И для этого мы знаем, что синтаксис — знак доллара и звёздочка.

336
00:31:16,540 --> 00:31:21,260
И теперь для этого отдельного значения, которое у нас здесь есть и на которое мы ссылаемся.

337
00:31:21,340 --> 00:31:26,380
Так что для каждого параметра в этом списке мы хотим выполнить некоторую логику.

338
00:31:26,380 --> 00:31:30,540
И чтобы это сделать, у нас есть, опять же, ещё одно ключевое слово, называемое do.

339
00:31:31,740 --> 00:31:33,660
И мы немного это отступим.

340
00:31:34,620 --> 00:31:39,820
И блок do по сути будет содержать логику, которую мы хотим выполнить

341
00:31:39,820 --> 00:31:44,220
для каждого конкретного элемента в этом списке, по которому мы проходим.

342
00:31:44,220 --> 00:31:48,780
В нашем случае давайте просто выводить фактические значения одно за другим.

343
00:31:48,780 --> 00:31:51,340
Так что я просто сделаю echo и param.

344
00:31:52,300 --> 00:31:57,340
И так же, как в моём операторе if, чтобы сказать программе,

345
00:31:57,340 --> 00:32:00,060
эй, мы закончили здесь, мы собираемся сделать done.

346
00:32:02,140 --> 00:32:03,340
И на этом всё.

347
00:32:03,980 --> 00:32:07,820
Итак, теперь пару вещей, которые стоит здесь упомянуть.

348
00:32:07,820 --> 00:32:12,780
Прежде всего, у нас есть этот отступ, как у нас было в операторах if.

349
00:32:12,780 --> 00:32:18,220
И это в основном для нас, чтобы нам было проще и чище читать

350
00:32:18,220 --> 00:32:19,020
для программы.

351
00:32:19,020 --> 00:32:20,140
Это не особо важно.

352
00:32:20,140 --> 00:32:22,940
Вообще, мы можем написать все это в одну строку.

353
00:32:22,940 --> 00:32:27,420
Отступы просто дают чуть более понятный вид логики.

354
00:32:28,060 --> 00:32:34,620
Второй момент, который хочу отметить: это по сути то же самое, что присвоить

355
00:32:34,620 --> 00:32:38,220
конкретный параметр переменной под названием param.

356
00:32:38,220 --> 00:32:44,460
Так же, как мы делали в предыдущих случаях, где мы, по сути, считывали первый параметр и

357
00:32:44,460 --> 00:32:51,020
присваивали его переменной с названием config file вот так.

358
00:32:51,020 --> 00:32:52,300
Это то, что мы делаем здесь.

359
00:32:52,300 --> 00:32:57,180
Но вместо этого мы делаем это для каждого элемента в списке params.

360
00:32:57,180 --> 00:33:00,220
И мы обращаемся к ним как к переменной param.

361
00:33:02,860 --> 00:33:03,340
Вот так.

362
00:33:03,980 --> 00:33:09,980
Итак, когда это запустится впервые, он увидит, что это список, в котором, возможно, пять

363
00:33:09,980 --> 00:33:16,620
или четыре параметра, неважно, он присвоит первый параметр этой переменной param

364
00:33:16,620 --> 00:33:18,540
и выведет его.

365
00:33:18,540 --> 00:33:20,540
Затем он пройдет по списку.

366
00:33:20,540 --> 00:33:27,260
Снова он увидит, что есть второй элемент, и теперь присвоит параметр два

367
00:33:27,260 --> 00:33:33,500
переменной param, а затем выведет его и так далее, пока в списке ничего не останется.

368
00:33:34,460 --> 00:33:41,820
Чтобы показать это выполнение, давайте запустим наш скрипт.

369
00:33:42,380 --> 00:33:49,660
И когда мы не передаем никаких параметров, вы видите, что в цикле for ничего не происходит.

370
00:33:49,660 --> 00:33:51,660
По сути, мы не видим никакого вывода.

371
00:33:51,660 --> 00:34:01,740
Теперь давайте передадим name и last name и фактически запустим наш предыдущий пример с

372
00:34:01,980 --> 00:34:03,340
пятью параметрами.

373
00:34:03,340 --> 00:34:04,060
Вот так.

374
00:34:04,060 --> 00:34:12,540
То есть каждое значение в списке параметров выводится этим циклом for по одному.

375
00:34:13,900 --> 00:34:20,300
Очевидно, что просто выводить значения по одному не очень полезно.

376
00:34:20,300 --> 00:34:26,620
Однако вы можете написать любую логику и выполнять ее с помощью цикла for для отдельных

377
00:34:26,620 --> 00:34:28,060
значений в списке.

378
00:34:28,060 --> 00:34:32,300
Например, в нашем случае мы можем проверять каждый параметр.

379
00:34:32,300 --> 00:34:39,020
Например, является ли он файлом или, возможно, это имя директории или местоположение чего-то

380
00:34:39,020 --> 00:34:43,180
и затем на основании этого условия мы можем решить, что делать с этим значением.

381
00:34:43,180 --> 00:34:49,900
Так, например, скажем, мы ожидаем местоположение всех конфигурационных скриптов в

382
00:34:49,900 --> 00:34:51,100
переданных параметрах.

383
00:34:51,100 --> 00:34:52,940
Мы можем это проверить.

384
00:34:52,940 --> 00:35:05,500
То есть мы сделаем: если один из переданных параметров — это директория, то, возможно, мы пишем

385
00:35:05,500 --> 00:35:11,180
логику, которая выполняет скрипты в этом конфигурационном файле.

386
00:35:11,180 --> 00:35:17,260
То есть выполняем скрипты в папке config.

387
00:35:17,580 --> 00:35:25,020
И, очевидно, для всех параметров, которые не являются директорией, то есть условие ложно.

388
00:35:26,220 --> 00:35:28,220
Это не будет выполняться, верно?

389
00:35:28,220 --> 00:35:36,140
Так что у нас есть else: не директория.

390
00:35:37,020 --> 00:35:43,980
Или мы можем вообще обойтись без операторов else, потому что если это не директория, то мы

391
00:35:44,460 --> 00:35:47,900
просто выводим параметр как раньше.

392
00:35:48,540 --> 00:35:52,060
И это применимо ко всем параметрам.

393
00:35:52,060 --> 00:35:54,700
И прямо здесь мы можем также сделать ls.

394
00:35:56,780 --> 00:36:01,020
Так мы можем вывести содержимое этой папки вот так.

395
00:36:01,020 --> 00:36:04,540
Давайте сохраним и запустим снова.

396
00:36:04,540 --> 00:36:05,660
Вот так.

397
00:36:05,660 --> 00:36:10,860
Итак, сначала у нас nada, затем admin, затем config.yaml.

398
00:36:10,940 --> 00:36:14,940
А здесь следующий параметр — setup scripts.

399
00:36:14,940 --> 00:36:19,180
И в операторе if он, по сути, обнаружил, что это директория.

400
00:36:19,180 --> 00:36:27,420
Так что условие if затем было выполнено, и команда ls запустилась, а потом последний параметр.

401
00:36:27,420 --> 00:36:31,340
И таким же образом вы можете добавить условия для каждого параметра.

402
00:36:31,340 --> 00:36:35,900
Например, мы проверяем, является ли это каталогом, для следующего можем проверить

403
00:36:35,900 --> 00:36:42,620
является ли это файлом, можем проверить, является ли это пользователем и конкретным именем пользователя Linux и т.д.

404
00:36:42,620 --> 00:36:47,340
И как я сказала, когда вы работаете со списками, у вас есть список серверов,

405
00:36:47,340 --> 00:36:52,140
у вас есть список программ, список ПО, которое хотите установить,

406
00:36:52,140 --> 00:36:56,300
вы будете использовать цикл for, чтобы пройти по этому списку.

407
00:36:56,300 --> 00:37:00,940
И для каждого элемента в списке выполнять любую нужную логику.

408
00:37:00,940 --> 00:37:06,860
Так что когда вы хотите выполнить что-то несколько раз или для каждого элемента списка,

409
00:37:06,860 --> 00:37:09,340
для этого и нужен цикл for.

410
00:37:09,340 --> 00:37:17,260
Однако у нас есть другой цикл, который называется while, он не используется для прохода по списку

411
00:37:17,260 --> 00:37:19,500
и выполнения чего-то для каждого элемента.

412
00:37:19,500 --> 00:37:25,740
А это цикл, который работает, пока выполняется определенное условие.

413
00:37:25,740 --> 00:37:33,420
Например, мы хотим написать программу, которая пингует сервис, только что запущенный,

414
00:37:33,420 --> 00:37:35,580
пока он не станет доступен.

415
00:37:35,580 --> 00:37:40,860
А потом, возможно, в конце выводит сообщение об успехе, что сервис успешно запущен.

416
00:37:40,860 --> 00:37:48,060
Или, возможно, мы хотим запускать скрипт каждые 10 секунд, который по сути мониторит

417
00:37:48,060 --> 00:37:52,940
какой-то endpoint, проверяет, что приложение доступно каждые 10 секунд.

418
00:37:53,740 --> 00:37:56,700
Поэтому он должен запускаться снова и снова в цикле.

419
00:37:56,700 --> 00:38:04,300
Или, возможно, у нас есть скрипт, который устанавливает ПО и затем ждет завершения установки,

420
00:38:04,300 --> 00:38:08,940
чтобы проверить, что команда этого ПО доступна.

421
00:38:08,940 --> 00:38:14,060
То есть ждём, пока выполнится условие доступности команды.

422
00:38:14,060 --> 00:38:16,380
И это цикл while.

423
00:38:16,380 --> 00:38:19,740
И его синтаксис тоже очень простой.

424
00:38:19,740 --> 00:38:25,020
У нас есть while, а затем условие, как в операторе if.

425
00:38:25,020 --> 00:38:29,260
Так что здесь можем иметь тот же тип условия, что и в if.

426
00:38:29,260 --> 00:38:35,420
Какое бы условие мы ни написали, пока оно истинно, цикл будет выполняться.

427
00:38:35,420 --> 00:38:41,260
Любая логика в цикле будет выполняться, очень распространённый случай использования while

428
00:38:41,260 --> 00:38:49,340
с распространённым условием — запуск в бесконечном цикле с условием, которое

429
00:38:49,340 --> 00:38:58,620
всегда истинно. То есть жёстко прописывая true здесь, while true, и затем используем тот же синтаксис, что и раньше,

430
00:38:59,420 --> 00:39:01,500
do, а затем done.

431
00:39:02,220 --> 00:39:04,300
И дальше у нас идёт логика.

432
00:39:04,300 --> 00:39:10,300
То есть мы запускаем этот цикл бесконечно и логику выхода из цикла размещаем

433
00:39:10,940 --> 00:39:11,820
внутри.

434
00:39:11,820 --> 00:39:17,900
Например, давайте напишем простую программу, которая принимает ввод пользователя.

435
00:39:18,540 --> 00:39:25,180
Мы сделаем read и попросим: введите оценку.

436
00:39:27,100 --> 00:39:29,500
Затем мы сохраняем эту оценку в переменную.

437
00:39:32,300 --> 00:39:34,300
Назовём её score.

438
00:39:36,380 --> 00:39:40,460
То есть мы напишем простую программу, которая снова и снова спрашивает

439
00:39:40,460 --> 00:39:43,180
пользователя о вводе оценки.

440
00:39:43,180 --> 00:39:47,180
И затем просто складываем все эти введённые оценки.

441
00:39:47,180 --> 00:39:48,620
То есть мы суммируем их.

442
00:39:49,740 --> 00:39:59,420
Оценка, которую пользователь ввёл, будет добавлена к переменной с названием sum.

443
00:39:59,420 --> 00:40:03,180
Эту переменную можно объявить снаружи вот так.

444
00:40:03,820 --> 00:40:05,580
То есть у нас sum ноль.

445
00:40:07,260 --> 00:40:08,620
Мы начинаем с нуля.

446
00:40:08,620 --> 00:40:15,020
И затем мы фактически меняем эту переменную, которую определили вне цикла,

447
00:40:15,900 --> 00:40:17,100
внутри цикла while.

448
00:40:17,100 --> 00:40:26,540
Каждый раз, когда пользователь вводит новую оценку, мы добавляем эту оценку к существующему значению здесь

449
00:40:26,540 --> 00:40:29,660
и присваиваем обратно переменной sum.

450
00:40:29,660 --> 00:40:33,900
Так что оценка будет добавляться и добавляться при каждом вводе пользователя.

451
00:40:34,860 --> 00:40:44,700
И в какой-то момент мы можем вывести общую сумму очков

452
00:40:46,940 --> 00:40:50,780
просто распечатав значение переменной sum.

453
00:40:51,500 --> 00:40:57,180
Однако этот цикл будет выполняться бесконечно, потому что у нас есть жестко заданное условие,

454
00:40:57,180 --> 00:40:58,620
которое всегда истинно.

455
00:40:59,340 --> 00:41:04,540
Поэтому нам нужен способ выйти из цикла, когда условие выполнено.

456
00:41:04,540 --> 00:41:10,860
Так что мы сделаем: позволим пользователю завершить программу, или по сути

457
00:41:11,660 --> 00:41:14,380
дать пользователю сказать: эй, я закончил с этой программой.

458
00:41:14,380 --> 00:41:17,180
Я хочу выйти или завершить программу.

459
00:41:17,180 --> 00:41:24,940
Поэтому мы позволим пользователю вместо очка ввести букву Q.

460
00:41:24,940 --> 00:41:27,900
И прямо здесь мы проверим,

461
00:41:31,020 --> 00:41:37,180
является ли введенное пользователем значение буквой Q.

462
00:41:38,860 --> 00:41:43,420
И снова, не забудьте двойные кавычки здесь.

463
00:41:44,380 --> 00:41:50,540
Если это правда, это означает, что пользователь хочет выйти из программы.

464
00:41:51,500 --> 00:41:55,500
Тогда мы делаем break.

465
00:41:56,860 --> 00:41:59,020
То есть выходим из цикла.

466
00:41:59,820 --> 00:42:02,300
И затем завершаем оператор if.

467
00:42:03,980 --> 00:42:09,180
Так что это по сути будет выполняться снова и снова, спрашивая у пользователя его ввод для очков.

468
00:42:09,740 --> 00:42:17,340
И каждый раз, когда пользователь вводит число очков, оно будет суммироваться и выводить

469
00:42:18,060 --> 00:42:22,060
общую сумму здесь после каждой итерации.

470
00:42:22,060 --> 00:42:27,180
Однако должен быть какой-то способ остановить программу и остановить выполнение цикла.

471
00:42:27,180 --> 00:42:31,260
Поэтому мы позволяем пользователю ввести Q, что означает, что мы прерываем программу.

472
00:42:31,260 --> 00:42:32,540
Мы выходим.

473
00:42:32,540 --> 00:42:36,540
Однако, прежде чем выполнить эту программу, есть одна вещь, которую нужно исправить.

474
00:42:36,540 --> 00:42:41,180
И это вычисление прямо здесь.

475
00:42:41,180 --> 00:42:49,180
Сейчас, с этой логикой, это выражение будет интерпретироваться как сложение двух строк

476
00:42:49,180 --> 00:42:50,700
друг с другом вместо двух чисел.

477
00:42:51,420 --> 00:42:56,140
Для арифметических операций мы используем синтаксис двойных скобок вот так.

478
00:42:57,180 --> 00:43:01,100
И это контейнер для выражения в bash.

479
00:43:01,100 --> 00:43:03,420
Так что это на самом деле исправляет проблему.

480
00:43:03,420 --> 00:43:07,740
И это действительно будет посчитано как сложение двух чисел.

481
00:43:08,300 --> 00:43:13,020
Давайте сохраним это и запустим без параметров.

482
00:43:13,820 --> 00:43:17,660
А теперь введем очко, которое равно 10.

483
00:43:17,660 --> 00:43:19,820
Мы сразу получили общую сумму.

484
00:43:19,820 --> 00:43:22,060
Затем вводим другое очко, например 20.

485
00:43:22,060 --> 00:43:25,420
Давайте введем 12 и так далее.

486
00:43:25,420 --> 00:43:31,500
То есть, по сути, эта программа будет выполняться бесконечно, потому что у нас есть условие

487
00:43:32,060 --> 00:43:35,740
true, которое жестко прописано как истинное условие.

488
00:43:36,700 --> 00:43:46,860
И она будет выполняться снова и снова, пока мы не введем Q вместо фактического очка.

489
00:43:46,860 --> 00:43:52,620
И если я выполню это, программа завершится, потому что внутри есть условие,

490
00:43:52,620 --> 00:43:59,260
которое проверяет ввод, равен ли он Q, и затем разрывает цикл.

491
00:43:59,260 --> 00:44:00,940
Так что программа завершится на этом.

492
00:44:01,740 --> 00:44:07,660
Еще одна интересная деталь в том, что в bash есть альтернативный синтаксис для квадратных скобок,

493
00:44:08,220 --> 00:44:11,900
которые мы используем для условных выражений и if.

494
00:44:11,900 --> 00:44:15,340
А альтернатива — это двойные квадратные скобки.

495
00:44:15,340 --> 00:44:20,620
Так что если вы видите bash-скрипты с двойными квадратными скобками, это, по сути, то же самое,

496
00:44:20,620 --> 00:44:22,860
но с большим количеством возможностей.

497
00:44:22,860 --> 00:44:27,180
То есть это улучшенная версия одинарных квадратных скобок.

498
00:44:27,180 --> 00:44:30,700
Одно улучшение, например, в том, что при использовании двойных скобок

499
00:44:30,700 --> 00:44:34,540
не нужно заключать имена переменных в кавычки.

500
00:44:34,540 --> 00:44:38,780
Так что в целом, как видите, у bash-скриптов довольно сложный синтаксис,

501
00:44:38,780 --> 00:44:40,700
что не очень интуитивно.

502
00:44:40,700 --> 00:44:45,180
Поэтому, хотя он очень полезен для автоматизации задач DevOps,

503
00:44:45,180 --> 00:44:48,620
для некоторых из этих задач существуют более удачные альтернативы.

504
00:44:49,260 --> 00:44:52,140
используя язык программирования, например Python,

505
00:44:52,700 --> 00:44:59,980
или инструмент конфигурации вроде Ansible, которым вы тоже можете автоматизировать некоторые из тех же процессов.

506
00:44:59,980 --> 00:45:03,260
И мы изучим оба этих инструмента на этом буткемпе.

507
00:45:03,260 --> 00:45:09,580
Однако, изучая все эти разные варианты, вы всё равно получите огромное преимущество,

508
00:45:09,580 --> 00:45:14,780
включая bash-скрипты, потому что будете знать, каковы преимущества и недостатки

509
00:45:14,780 --> 00:45:17,980
каждого и как они соотносятся друг с другом.

510
00:45:17,980 --> 00:45:22,780
И все эти знания определённо сделают вас очень ценным инженером DevOps.

