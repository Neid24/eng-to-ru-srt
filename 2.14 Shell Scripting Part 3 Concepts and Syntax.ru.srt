1
00:00:00,000 --> 00:00:12,280
И наконец, последний концепт, который я хочу объяснить в batch-скриптах, — это концепт

2
00:00:12,280 --> 00:00:21,120
функций. Теперь давайте посмотрим на наш batch-скрипт. И хотя у нас здесь очень простой,

3
00:00:21,120 --> 00:00:27,920
супербазовый пример, наш batch-скрипт уже состоит из пары строк, правда?

4
00:00:27,920 --> 00:00:33,760
У нас здесь есть некоторые условия с if и циклами и т.д. Так что представьте, что вы действительно

5
00:00:33,760 --> 00:00:42,200
пишете реальный скрипт конфигурации сервера или мониторинговый скрипт или что-то подобное, какую-то сложную

6
00:00:42,200 --> 00:00:47,200
логику в своем batch-скрипте — у вас будет очень много кода внутри, возможно

7
00:00:47,200 --> 00:00:55,080
сотни строк. И вся эта штука на самом деле станет очень трудной для чтения. И

8
00:00:55,080 --> 00:01:02,400
чтобы у вас было общее представление о том, что происходит в скрипте. Также, если вы делаете похожие

9
00:01:02,400 --> 00:01:08,880
вещи на сервере, вы можете получить много кода, который на самом деле делает почти ту же логику,

10
00:01:08,880 --> 00:01:14,960
но вам приходится повторять его во многих разных местах, потому что вы хотите выполнить эту задачу,

11
00:01:14,960 --> 00:01:22,120
верно? Итак, чтобы решить эти проблемы и по сути помочь вам немного почистить ваш скрипт,

12
00:01:22,600 --> 00:01:30,400
у нас есть концепт функций. Итак, функция — это по сути способ сгруппировать некоторый набор логики,

13
00:01:30,400 --> 00:01:39,280
набор команд, блок кода, по сути, в переиспользуемый компонент. То есть, по сути, это

14
00:01:39,280 --> 00:01:47,640
как контейнер для блока логики, для набора команд, которым вы можете дать имя,

15
00:01:48,280 --> 00:01:53,840
а затем вы можете ссылаться на весь этот блок кода, используя это имя, так же как мы делали с

16
00:01:53,840 --> 00:01:59,680
переменной. Так что если у вас есть похожая логика, которую вы хотите выполнить в трех разных местах в

17
00:01:59,680 --> 00:02:06,560
вашем скрипте, вы можете сохранить этот код в функцию. А затем вы можете ссылаться на эту функцию

18
00:02:06,560 --> 00:02:12,000
в вашем скрипте. И также, как я сказал, функция — это способ почистить ваш скрипт. То есть

19
00:02:12,000 --> 00:02:18,960
сгруппировать вещи вместе и дать им логические имена. Так что ваш скрипт проще читать и

20
00:02:18,960 --> 00:02:25,120
поддерживать. И давайте посмотрим, как это работает. Итак, прямо здесь, вместо того чтобы иметь этот блок кода,

21
00:02:25,120 --> 00:02:32,480
то есть по сути программу, которая делает что-то конкретное, я хочу поместить ее в функцию,

22
00:02:32,480 --> 00:02:39,840
дать ей имя и затем по сути решить, где и сколько раз я хочу выполнять эту логику.

23
00:02:40,120 --> 00:02:46,320
Чтобы поместить это в функцию, у нас есть ключевое слово function, а затем у нас есть имя

24
00:02:46,320 --> 00:02:52,200
функции, так же как мы называли наши переменные, нам нужно назвать и наши функции. И давайте назовем это

25
00:02:52,200 --> 00:03:06,920
score game или score sum. И затем у нас есть фигурные скобки, вот так. И между этими фигурными

26
00:03:06,960 --> 00:03:14,960
скобками мы можем написать логику нашей функции. В нашем случае мы просто хотим поместить все это в

27
00:03:14,960 --> 00:03:24,080
функцию. Так что я собираюсь скопировать это и вставить сюда. Снова обратите внимание на отступы, которые мы

28
00:03:24,080 --> 00:03:30,840
используем. То есть у нас есть внешняя строка определения функции, и затем все внутри. То есть

29
00:03:30,840 --> 00:03:35,920
все внутри функции по сути немного с отступом. Так мы видим, что все это

30
00:03:35,920 --> 00:03:45,040
принадлежит функции. Опять же, это во многом предпочтение пользователя для простой читаемости. И я просто

31
00:03:45,040 --> 00:03:56,000
собираюсь удалить 10 строк здесь, может больше. И вот так. Отлично. Итак, у нас есть наша первая функция

32
00:03:56,000 --> 00:04:02,840
которая содержит ту программу, которую мы написали раньше. Теперь давайте посмотрим, что произойдет, если я сохраню это,

33
00:04:03,640 --> 00:04:11,920
и мы выполним наш скрипт. Видите, на самом деле ничего не произошло. У нас просто есть здесь эти две строки.

34
00:04:11,920 --> 00:04:21,200
Цикл for был выполнен, но у нас не было никаких параметров, и ничего не было выведено здесь. Но

35
00:04:21,200 --> 00:04:27,120
все это на самом деле не произошло. То есть у нас не спросили счет. И эта программа не запустилась. Так что

36
00:04:27,120 --> 00:04:33,360
случилось здесь то, что когда мы создаем функцию, мы просто определяем функцию. Так же

37
00:04:33,360 --> 00:04:40,520
как мы создаем переменную, мы просто определяем имя my var и затем назначаем значение. Это

38
00:04:40,520 --> 00:04:45,960
не выводит значение переменной, верно, это просто создает переменную. И все, мы можем потом

39
00:04:45,960 --> 00:04:53,520
позже фактически использовать эту переменную, чтобы вывести ее или сделать с ней что угодно. И работает то же

40
00:04:53,600 --> 00:05:01,440
самое с функциями, мы создаем функцию, но мы должны использовать ее, если хотим на самом деле увидеть

41
00:05:01,440 --> 00:05:11,240
выполнение функции. И чтобы выполнить функцию, мы просто используем ее имя, вот так. И все.

42
00:05:11,480 --> 00:05:25,440
И давайте сохраним это и выполним. И теперь у нас работает программа. Давайте выйдем. Итак, опять

43
00:05:25,440 --> 00:05:31,560
очень похожая концепция с переменными, мы их создаем, определяем, и затем позже мы можем использовать их столько

44
00:05:31,920 --> 00:05:43,920
раз, сколько захотим. Теперь, как я сказал, функции обычно используются для того, чтобы содержать или группировать похожие

45
00:05:43,920 --> 00:05:50,680
блоки кода, не идентичные, но похожие. Это значит, что одно-два значения могут отличаться, но

46
00:05:50,680 --> 00:05:57,440
а в остальном остальная логика практически та же. Итак, например, у нас может быть

47
00:05:57,640 --> 00:06:11,160
функция, которую мы используем для создания файла. И мы назовем ее create file function. И мы

48
00:06:11,160 --> 00:06:18,520
хотим использовать эту функцию для любого типа файла. То есть когда внутри скрипта мы хотим создать

49
00:06:18,520 --> 00:06:24,000
любой файл, мы собираемся вызвать эту функцию. Однако каждый раз, когда мы создаем файл, мы будем

50
00:06:24,080 --> 00:06:30,040
давать ему разное значение, верно? Так что хотим сказать функции: создай файл с этим конкретным

51
00:06:30,040 --> 00:06:39,480
имя. И это имя на самом деле можно передать как параметр. Итак, как и прежде, у нас есть это

52
00:06:39,480 --> 00:06:48,680
определение функции. И после имени функции мы можем также указать пустые скобки. А затем внутри

53
00:06:48,720 --> 00:06:57,360
функции у нас есть фактическая логика создания этого файла с помощью команды touch. И затем у нас есть

54
00:06:57,360 --> 00:07:02,880
имя файла. Так как же нам прочитать тот параметр, который мы передаем функции?

55
00:07:02,880 --> 00:07:08,920
Синтаксис на самом деле такой же, как при чтении параметра при выполнении самого bash-скрипта.

56
00:07:08,920 --> 00:07:15,040
Так что, используя знак доллара и единицу, мы возьмем первый параметр этой функции. И мы можем

57
00:07:15,080 --> 00:07:22,040
также присвоить его переменной. Давайте сохраним его в переменную под названием file name. И после этого,

58
00:07:22,040 --> 00:07:30,360
мы можем создать файл, используя любое указанное имя. И снова помните, это только функция

59
00:07:30,360 --> 00:07:36,280
создания, она ничего не вызовет и ничего не сделает, пока мы ее не вызовем

60
00:07:36,280 --> 00:07:46,440
и не выполним. Поэтому я сделаю create file. А передать параметр очень просто,

61
00:07:46,440 --> 00:07:56,040
просто пробел и затем значение первого параметра. В нашем случае назовем это test.txt. И

62
00:07:56,040 --> 00:08:03,120
возможно, в другом месте скрипта нам снова понадобится та же логика создания файла,

63
00:08:03,360 --> 00:08:10,200
но с другим именем файла или другим типом. Пусть это будет my file точка

64
00:08:11,200 --> 00:08:18,480
YAML, другое место в скрипте, где мы хотим создать shell-скрипт. И назовем его my

65
00:08:18,480 --> 00:08:27,680
script точка sh. И теперь мы можем протестировать нашу функцию. Прежде чем это сделать, я хочу игнорировать

66
00:08:27,680 --> 00:08:35,560
вывод вот здесь. То есть эти две команды echo. Однако я не хочу удалять их из кода,

67
00:08:35,560 --> 00:08:42,760
потому что они могут понадобиться позже. Поэтому удобный способ игнорировать выполнение команды, не

68
00:08:42,760 --> 00:08:50,480
удаляя ее, - это так называемое комментирование в bash. Когда вы начинаете строку с

69
00:08:50,520 --> 00:08:59,360
символа решетки, программа ее проигнорирует. То есть она не будет выполнена как команда,

70
00:08:59,360 --> 00:09:04,680
она будет интерпретирована как комментарий. И это очень удобно, потому что вы можете

71
00:09:04,680 --> 00:09:11,400
оставлять себе информацию и заметки по всему bash-скрипту, используя комментарии,

72
00:09:11,400 --> 00:09:17,000
где можно писать обычные предложения, описывающие, что делает функция или что делает

73
00:09:17,000 --> 00:09:24,720
блок кода, или почему вы выбрали определенную логику и т.д. Так что для этого нужны комментарии,

74
00:09:24,720 --> 00:09:31,160
чтобы не иметь лишнего вывода. Теперь давайте просто выведем здесь,

75
00:09:31,160 --> 00:09:54,800
файл с любым указанным именем создан вот так. Давайте сохраним и выполним. И вот

76
00:09:54,800 --> 00:10:06,080
готово. Если я сделаю ls, я увижу все три файла здесь. Теперь давайте удалим их снова. Используя

77
00:10:06,080 --> 00:10:16,520
команду rm. Вернемся к скрипту. И давайте посмотрим, как можно передать другой параметр, потому что

78
00:10:16,520 --> 00:10:22,680
функции могут иметь несколько параметров, так же как и наш скрипт может иметь несколько параметров. И чем

79
00:10:22,720 --> 00:10:29,480
более настраиваемой или переиспользуемой вы хотите сделать функцию, тем больше параметров нужно

80
00:10:29,480 --> 00:10:36,040
добавлять. Однако есть стандартное руководство по наилучшей практике о том, сколько параметров на функцию

81
00:10:36,040 --> 00:10:42,480
следует принимать. Больше пяти параметров на функцию - это слишком много. Причина в том, что

82
00:10:42,480 --> 00:10:50,760
одна из концепций функции - иметь маленькие переиспользуемые куски кода. Поэтому если вы

83
00:10:51,120 --> 00:10:57,360
передаете функции слишком много параметров, возможно, она делает слишком много. Поэтому

84
00:10:57,360 --> 00:11:04,120
можно разделить ее на меньшие функции. Однако это лишь один из примеров

85
00:11:04,120 --> 00:11:11,480
лучших практик написания правильного скрипта, который читаем, поддерживаем и т.д. Итак, с этим

86
00:11:11,480 --> 00:11:19,320
давайте посмотрим использование второго параметра. И скажем, что в качестве второго параметра мы хотим

87
00:11:19,440 --> 00:11:27,080
принимать логический флаг, говорящий, является ли создаваемый файл shell-скриптом или нет.

88
00:11:27,880 --> 00:11:35,560
Что такое Boolean или логическое значение? Boolean - это по сути тип данных, представляющий два возможных

89
00:11:35,560 --> 00:11:43,400
значения. И это общее для всех языков программирования, включая bash. Одним

90
00:11:43,400 --> 00:11:49,560
значением Boolean является true, а другим - false. В if и while

91
00:11:49,560 --> 00:11:56,600
мы изучали условные конструкции, где оцениваем некоторую логику и решаем, истинна она или ложна.

92
00:11:57,400 --> 00:12:03,880
И возвращаемое значение на самом деле логическое. Поэтому мы хотим передать этой функции

93
00:12:03,880 --> 00:12:11,240
логическое значение true или false, которое говорит функции, является ли создаваемый файл

94
00:12:11,320 --> 00:12:19,240
shell-скриптом или нет. Так что второй параметр будет is shell script.

95
00:12:21,240 --> 00:12:26,200
И мы читаем его из второго параметра. И после того как создадим файл,

96
00:12:28,040 --> 00:12:38,120
если создаваемый файл - shell-скрипт .sh, мы хотим добавить ему право на выполнение.

97
00:12:38,920 --> 00:12:39,640
Итак, если

98
00:12:42,840 --> 00:12:52,280
is shell script равно true. True - одно из значений Boolean. И это по сути

99
00:12:52,280 --> 00:12:56,760
просто жестко заданное условие true. У нас также есть false

100
00:12:59,560 --> 00:13:06,440
вот так. То есть мы говорим, что параметр is shell script равен true. Тогда

101
00:13:08,680 --> 00:13:17,640
выполните команду change mode, чтобы пользователю добавить разрешение на выполнение для указанного имени файла.

102
00:13:19,000 --> 00:13:24,520
И нам нужно закрыть оператор if. Поэтому здесь красная линия.

103
00:13:26,760 --> 00:13:33,240
И при создании файла my script.sh мы передадим второй параметр

104
00:13:33,240 --> 00:13:38,520
со значением true. Вы видите подсветку синтаксиса, потому что true и false

105
00:13:39,320 --> 00:13:46,280
на самом деле являются ключевыми словами в bash. Поэтому bash понимает, что мы имеем в виду булево значение true,

106
00:13:46,920 --> 00:13:54,040
которое обрабатывается как специальное значение. То есть это наш второй параметр.

107
00:13:55,400 --> 00:14:01,640
А для тех двух файлов это будет пропущено, потому что мы не передаем второй параметр.

108
00:14:01,640 --> 00:14:10,680
Так что по умолчанию это не true. А для my script.sh он попытается добавить разрешение на выполнение.

109
00:14:10,680 --> 00:14:19,160
И, конечно, этот shell script — переменная. Поэтому нам нужно ссылаться на нее как на переменную, используя

110
00:14:20,840 --> 00:14:28,520
двойные кавычки. И давайте еще выведем здесь echo с текстом edit execute permission.

111
00:14:28,520 --> 00:14:36,760
Сохраняем. И запускаем скрипт. Вот, у нас три файла, которые были

112
00:14:36,760 --> 00:14:47,480
созданы, плюс edit execute permission. Теперь, если сделаем ls минус l, my script.sh имеет право

113
00:14:47,480 --> 00:14:57,000
на выполнение для пользователя. И, наконец, еще одна крутая вещь в функциях — мы можем

114
00:14:57,000 --> 00:15:04,200
на самом деле возвращать значения как результат выполнения функции. Например, если я хочу вернуть

115
00:15:05,560 --> 00:15:09,640
что-то в конце функции, я просто пишу return.

116
00:15:11,400 --> 00:15:17,720
И каким бы ни было это значение — это может быть само имя файла, это может быть... Обычно, когда вы

117
00:15:17,720 --> 00:15:23,800
вызываете функцию, функция обрабатывает, делает что-то с переданными значениями. И затем

118
00:15:23,800 --> 00:15:33,560
возвращает вам полученное значение. Классический пример — функция, которая вычисляет

119
00:15:33,560 --> 00:15:50,200
или суммирует два числа. И затем просто отдает нам результат выполнения. Так что

120
00:15:50,200 --> 00:16:00,600
давайте сделаем какую-нибудь переменную, total — неважно — равно. И потом, используя синтаксис выражений,

121
00:16:01,320 --> 00:16:11,240
у нас параметр один плюс параметр два. То есть складываем два значения, и затем можем их вывести

122
00:16:12,200 --> 00:16:25,720
обратно. Или, как я сказал, можем вернуть это значение. Так что если мы вызовем some function с двумя и десятью,

123
00:16:26,600 --> 00:16:34,600
эта функция вернет сумму этих двух значений. И мы можем

124
00:16:34,600 --> 00:16:41,400
сохранить результат этого выполнения в переменную. Один из способов — просто присвоить

125
00:16:44,600 --> 00:16:46,120
результат переменной.

126
00:16:48,760 --> 00:16:54,920
Как в примере с результатом выполнения команды, синтаксис которого мы уже видели. И другой

127
00:16:55,560 --> 00:17:02,600
интересный способ — вызвать функцию, а затем на следующей строке

128
00:17:03,560 --> 00:17:10,200
присвоить результат предыдущего выполнения команды переменной. Это на самом деле

129
00:17:10,200 --> 00:17:18,600
тоже распространенный случай и полезно знать, как получить результат или обратиться к результату

130
00:17:18,600 --> 00:17:26,520
предыдущей команды. И для этого у нас есть специальная переменная — доллар, вопросительный знак.

131
00:17:26,520 --> 00:17:34,600
Это даст нам фактически код возврата выполнения этой команды. И мы собираемся

132
00:17:34,600 --> 00:17:42,200
сохранить его в переменную под названием results. И если мы теперь выведем результат вот так, можно также сказать

133
00:17:42,920 --> 00:17:49,640
два и десять, или сумма двух и десяти равна

134
00:17:52,760 --> 00:17:55,960
вот так. И если я выполню

135
00:17:59,960 --> 00:18:07,160
вот так, пожалуйста, у нас «сумма двух и десяти равна 12». Такова величина

136
00:18:07,800 --> 00:18:10,840
result, которую мы сохранили здесь.

137
00:18:14,520 --> 00:18:22,200
Итак, это основы bash-скриптинга. И то, что вы только что узнали, — это основные строительные блоки

138
00:18:22,200 --> 00:18:28,760
и концепции bash-скриптинга. И снова, вы можете комбинировать все эти концепции, можете использовать функции

139
00:18:28,760 --> 00:18:35,960
в циклах, можете использовать условные операторы для разных случаев и т.д. И есть множество

140
00:18:35,960 --> 00:18:44,200
разных сценариев применения bash-скриптов. У нас могут быть скрипты, которые запускаются каждые 60

141
00:18:44,200 --> 00:18:50,680
секунд или пару минут и делают бэкапы, например, которые копируют

142
00:18:50,680 --> 00:18:58,200
папки и файлы и затем сохраняют их где-то еще. У нас могут быть скрипты, которые мониторят сеть,

143
00:18:58,200 --> 00:19:03,880
которые сканируют сеть и проверяют, что хосты доступны, или что конкретная программа

144
00:19:03,880 --> 00:19:09,240
работает, какие-то порты открыты и доступны. У нас могут быть скрипты, которые конфигурируют

145
00:19:09,240 --> 00:19:14,600
весь сервер, устанавливая новое ПО, создавая пользователей Linux и т.д. И мы также можем

146
00:19:14,600 --> 00:19:20,280
иметь скрипты, которые обращаются к внешним сервисам, внешним API и так далее. Так что многое

147
00:19:20,280 --> 00:19:27,400
можно сделать с помощью bash-скриптов. И по мере того как вы продвигаетесь по буткэмпу и изучаете новые технологии

148
00:19:27,400 --> 00:19:32,920
и разные задачи, которые как инженер DevOps вы будете делать ежедневно, вы увидите множество

149
00:19:32,920 --> 00:19:39,640
кейсов использования bash-скриптов или вообще скриптов. Поэтому всякий раз, когда вы захотите автоматизировать

150
00:19:39,640 --> 00:19:45,480
работу по конфигурации серверов командами bash, как инженер DevOps, вы можете писать bash-скрипты.

151
00:19:45,480 --> 00:19:50,440
А с bash-скриптами у вас есть переносимый файл, который служит документацией того, что нужно

152
00:19:50,440 --> 00:19:56,760
выполнять и в каком порядке. И конечно, им можно поделиться с коллегами, и его можно выполнять

153
00:19:56,760 --> 00:20:00,600
сколько угодно раз на разных серверах.

