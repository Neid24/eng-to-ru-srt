1
00:00:00,000 --> 00:00:06,440
В этой лекции мы поговорим об очень полезной концепции, которую мы будем

2
00:00:06,440 --> 00:00:13,080
использовать часто на протяжении буткемпа, а именно SSH, или Secure Shell.

3
00:00:13,080 --> 00:00:18,020
А теперь представьте: вы написали shell-скрипт и хотите скопировать его на другой

4
00:00:18,020 --> 00:00:24,480
сервер, чтобы выполнить его там, или хотите скопировать его сразу на 10 других серверов.

5
00:00:24,480 --> 00:00:28,840
Или у вас настроен новый сервер, и вы хотите получить к нему доступ, чтобы установить разное ПО

6
00:00:28,840 --> 00:00:30,560
и запустить свое приложение.

7
00:00:30,560 --> 00:00:35,860
Сервер может физически находиться в другом месте, возможно, в другой стране.

8
00:00:35,860 --> 00:00:41,200
Так как же получить доступ к этому серверу и настраивать что-то в его интерфейсе командной строки?

9
00:00:41,200 --> 00:00:44,480
Или как скопировать файл скрипта и выполнить его там?

10
00:00:44,480 --> 00:00:47,600
Вот для чего нужен SSH.

11
00:00:47,600 --> 00:00:51,040
SSH снова расшифровывается как Secure Shell.

12
00:00:51,040 --> 00:00:52,200
Почему Secure?

13
00:00:52,200 --> 00:00:58,280
Потому что мы обращаемся к машине через интернет и хотим подключаться к ней безопасно.

14
00:00:58,280 --> 00:01:03,480
Потому что это наш сервер, и никто другой не должен иметь возможность получить к нему доступ и что-то там делать.

15
00:01:03,480 --> 00:01:08,160
Это значит, нам нужно аутентифицироваться на удаленном сервере.

16
00:01:08,160 --> 00:01:13,060
И есть два способа аутентифицироваться на удаленном сервере через SSH.

17
00:01:13,060 --> 00:01:15,680
Первый — имя пользователя и пароль.

18
00:01:15,680 --> 00:01:23,160
И это для пользователя, зарегистрированного или созданного на том удаленном сервере, а не на вашем собственном ноутбуке

19
00:01:23,160 --> 00:01:24,540
или компьютере.

20
00:01:24,540 --> 00:01:25,760
И как это работает?

21
00:01:26,240 --> 00:01:29,280
Скажем, у нас есть удаленный сервер приложений.

22
00:01:29,280 --> 00:01:35,560
Это может быть сервер в собственном дата-центре нашей компании или у облачного провайдера

23
00:01:35,560 --> 00:01:37,560
например AWS.

24
00:01:37,560 --> 00:01:42,280
Обычно администратор сервера создаст одного или нескольких пользователей для разных участников команды

25
00:01:42,280 --> 00:01:49,200
на том удаленном сервере приложений, чтобы эти пользователи могли подключаться со своих

26
00:01:49,200 --> 00:01:52,080
собственных машин, своих ноутбуков.

27
00:01:52,080 --> 00:01:59,160
Теперь есть другой способ подключаться и проходить аутентификацию на удаленном сервере без

28
00:01:59,160 --> 00:02:07,880
постоянного ввода пароля, и он на самом деле даже безопаснее, чем аутентификация по имени пользователя и паролю.

29
00:02:07,880 --> 00:02:13,640
Это второй способ аутентификации — с использованием ключей SSH.

30
00:02:13,640 --> 00:02:15,080
Как это работает?

31
00:02:15,080 --> 00:02:21,960
Клиентская машина, которая подключается к удаленному серверу, создает пару ключей SSH, состоящую из публичного

32
00:02:21,960 --> 00:02:23,800
и приватного ключей.

33
00:02:23,800 --> 00:02:28,960
Ключи по сути — это просто зашифрованные значения случайных хэшей.

34
00:02:28,960 --> 00:02:35,040
Приватный ключ из пары — секретный ключ, к которому имеет доступ только клиентская машина, создавшая эту

35
00:02:35,040 --> 00:02:37,400
пару ключей.

36
00:02:37,400 --> 00:02:42,480
Поэтому этот ключ нужно надежно хранить на той клиентской машине, то есть на вашем

37
00:02:42,480 --> 00:02:47,040
ноутбуке, вашем компьютере, и не передавать никому.

38
00:02:47,040 --> 00:02:53,080
Публичный ключ, как следует из названия, открыт, и им можно делиться с другими, включая наш

39
00:02:53,080 --> 00:02:54,520
удаленный сервер.

40
00:02:54,520 --> 00:03:00,400
Установив публичный ключ на удаленном сервере, мы можем сообщить удаленному серверу, что клиентская

41
00:03:00,400 --> 00:03:06,840
машина, которой принадлежит этот публичный ключ, безопасна для подключения к нему или для разрешения подключений

42
00:03:06,840 --> 00:03:07,840
от нее.

43
00:03:07,840 --> 00:03:13,800
Клиент может «разблокировать» публичный ключ с помощью своего приватного ключа, когда подключается к удаленному серверу.

44
00:03:13,800 --> 00:03:18,560
По сути, для связи между

45
00:03:18,560 --> 00:03:21,040
клиентом и удаленным сервером требуется комбинация этих двух ключей.

46
00:03:21,040 --> 00:03:26,760
Таким образом, в этом случае каждый член команды создаст свою пару ключей SSH на своей машине, и

47
00:03:26,760 --> 00:03:34,760
затем администратор удаленного сервера сможет добавить публичные SSH-ключи всех членов команды

48
00:03:34,760 --> 00:03:37,320
на тот удаленный сервер.

49
00:03:37,320 --> 00:03:44,280
А после этого они смогут подключаться к удаленному серверу со своих машин, предоставляя SSH

50
00:03:44,280 --> 00:03:46,600
приватный ключ при подключении.

51
00:03:46,600 --> 00:03:52,280
И очевидно, никто другой, чей публичный SSH-ключ не зарегистрирован на удалённом сервере

52
00:03:52,280 --> 00:03:57,160
не будет авторизован для доступа к этому удалённому серверу.

53
00:03:57,160 --> 00:04:02,360
И поэтому это более безопасно.

54
00:04:02,360 --> 00:04:09,880
Также вы можете добавить пользователя на удалённый сервер для другого сервиса, не только для членов команды.

55
00:04:09,880 --> 00:04:15,360
И этот другой сервис может быть, например, приложением вроде Jenkins, которому тоже может понадобиться доступ

56
00:04:15,360 --> 00:04:22,920
к серверу приложения по SSH, чтобы копировать файлы или выполнять там скрипты.

57
00:04:22,920 --> 00:04:30,240
Поэтому мы можем создать пользователя Jenkins на удалённой машине, затем создать пару ключей SSH

58
00:04:30,240 --> 00:04:37,420
на машине с Jenkins и добавить публичный SSH-ключ Jenkins в список authorized keys

59
00:04:37,420 --> 00:04:39,000
на сервере приложения.

60
00:04:39,000 --> 00:04:45,480
Таким образом, мы можем позволить Jenkins автоматически подключаться по SSH к нашему серверу приложения

61
00:04:45,480 --> 00:04:52,280
и затем фактически выполнять команды в его интерфейсе командной строки.

62
00:04:52,280 --> 00:04:58,120
Теперь помните, мы говорили, что когда одна машина хочет подключиться к другой, соединение

63
00:04:58,120 --> 00:05:04,760
должно быть явно разрешено правилом брандмауэра, иначе любое такое соединение

64
00:05:04,760 --> 00:05:05,760
блокируется.

65
00:05:05,760 --> 00:05:12,040
И для ясности: аутентификация — это этап после того, как мы подключились к

66
00:05:12,040 --> 00:05:13,200
машине.

67
00:05:13,200 --> 00:05:18,920
Сначала это соединение должно быть разрешено, а затем аутентификация будет проверена

68
00:05:18,920 --> 00:05:20,000
сервером.

69
00:05:20,000 --> 00:05:26,960
Мы говорили, что брандмауэр всегда настраивает конкретный порт, на котором доступен сервер.

70
00:05:26,960 --> 00:05:31,360
И что этот порт всегда открыт для приложения.

71
00:05:31,360 --> 00:05:37,800
Так какой порт и какое приложение должно работать на сервере, чтобы принимать наш SSH

72
00:05:37,800 --> 00:05:38,800
запрос?

73
00:05:38,800 --> 00:05:46,240
Большинство операционных систем имеют встроенный сервис SSH, который по умолчанию

74
00:05:46,240 --> 00:05:48,040
запущен на машине.

75
00:05:48,040 --> 00:05:52,480
И сервис SSH всегда работает на порту 22.

76
00:05:52,480 --> 00:05:59,560
Поэтому мы открываем порт 22 на сервере, к которому хотим подключаться с помощью команды SSH.

77
00:05:59,560 --> 00:06:07,040
Это значит, что в правиле брандмауэра мы разрешаем доступ к порту 22 на сервере, к которому

78
00:06:07,040 --> 00:06:09,600
хотим подключаться по SSH.

79
00:06:09,600 --> 00:06:16,640
Я также упоминал, что в правилах брандмауэра можно настроить источник, то есть какие устройства

80
00:06:16,640 --> 00:06:19,600
извне могут получить доступ к этой машине.

81
00:06:19,600 --> 00:06:24,880
В случае веб-приложения мы говорили, что хотим разрешить доступ всем, и это безопасно,

82
00:06:24,880 --> 00:06:28,560
потому что у них есть доступ только к этому одному приложению.

83
00:06:28,560 --> 00:06:31,840
Они не могут получить доступ к другим сервисам на машине.

84
00:06:31,840 --> 00:06:38,160
Но соединение по SSH очень мощное, потому что когда вы подключаетесь к другой машине по SSH,

85
00:06:38,160 --> 00:06:44,000
вы получаете доступ ко всей системе и её интерфейсу командной строки.

86
00:06:44,000 --> 00:06:46,080
Так что там можно делать многое.

87
00:06:46,080 --> 00:06:51,840
Поэтому такое соединение должно быть разрешено только людям, которые администрируют этот сервер.

88
00:06:51,840 --> 00:06:59,940
Поэтому вы можете настроить правило брандмауэра для порта 22 для определённых IP-адресов из белого списка, таких как

89
00:06:59,940 --> 00:07:05,400
IP-адрес вашей машины или IP-адреса всех администраторов сервера.

90
00:07:05,400 --> 00:07:11,360
Вот так работает SSH, а теперь давайте посмотрим простой пример в действии.

91
00:07:11,360 --> 00:07:16,440
Мы создадим удалённый сервер на облачной платформе.

92
00:07:16,440 --> 00:07:23,920
Мы создадим пару ключей SSH на нашем ноутбуке, чтобы можно было входить без пароля,

93
00:07:23,920 --> 00:07:30,800
а затем скопируем файл сценария — очень простой bash-скрипт — на удалённый сервер,

94
00:07:30,800 --> 00:07:34,840
подключимся к серверу по SSH и выполним этот файл сценария там.

95
00:07:34,840 --> 00:07:36,040
Давайте сделаем это.

96
00:07:36,040 --> 00:07:41,560
И первым шагом мы создадим виртуальный сервер на облачной платформе,

97
00:07:41,560 --> 00:07:47,640
которая называется DigitalOcean, и вы узнаете больше об облачных платформах в целом и о том,

98
00:07:47,640 --> 00:07:51,640
как работать на DigitalOcean, как создавать серверы и т. д.

99
00:07:51,640 --> 00:07:57,560
В следующем модуле я просто хочу создать сервер, который называется droplet

100
00:07:57,560 --> 00:08:01,480
в DigitalOcean, а затем подключиться к нему по SSH.

101
00:08:01,480 --> 00:08:05,640
Так что просто следуйте за мной, тут всё довольно просто.

102
00:08:05,640 --> 00:08:08,160
Мы просто нажимаем «Create droplets».

103
00:08:08,160 --> 00:08:14,040
Начинаем с выбора региона, ближайшего к вам; для меня это будет Франкфурт.

104
00:08:14,040 --> 00:08:23,240
Затем выбираем ОС, например Ubuntu, обычный SSD; всё остальное можно

105
00:08:23,240 --> 00:08:30,520
оставить по умолчанию и выбрать самый маленький сервер, а здесь в разделе аутентификации

106
00:08:30,520 --> 00:08:33,620
мы выберем аутентификацию по паролю.

107
00:08:33,620 --> 00:08:38,860
Это будет пароль, по которому мы будем подключаться к серверу.

108
00:08:38,860 --> 00:08:43,720
На первом шаге мы ничего не делаем с ключами SSH и просто вводим здесь пароль

109
00:08:43,720 --> 00:08:49,160
который хотите создать для пользователя, а по умолчанию нам даётся пользователь root,

110
00:08:49,160 --> 00:08:54,020
так что это будет пароль пользователя root, и я просто введу здесь пароль,

111
00:08:54,020 --> 00:09:04,060
который должен соответствовать этим требованиям.

112
00:09:04,060 --> 00:09:19,400
Вот и всё, больше ничего не выбираем, просто нажимаем «Create».

113
00:09:19,400 --> 00:09:27,040
И это создаст нам сервер на облачной платформе DigitalOcean, к которому мы сможем подключиться.

114
00:09:27,040 --> 00:09:36,560
Итак, это наш сервер, назовём его удалённым сервером, и, как вы уже знаете, каждый сервер

115
00:09:36,560 --> 00:09:42,720
или любое устройство в сети имеет IP-адрес, и наш сервер, который мы создали

116
00:09:42,720 --> 00:09:47,740
на платформе DigitalOcean, будет иметь публичный IP-адрес.

117
00:09:47,740 --> 00:09:52,940
То есть IP-адрес, к которому мы можем напрямую подключиться, и это тот адрес, который нам нужно

118
00:09:52,940 --> 00:10:00,100
для подключения к серверу по SSH.

119
00:10:00,100 --> 00:10:07,100
Я скопирую его, и теперь со своего компьютера с Linux или ноутбука, неважно,

120
00:10:07,100 --> 00:10:12,020
мы подключимся к этому удалённому серверу. Сделаем это с помощью команды SSH,

121
00:10:12,020 --> 00:10:17,300
что на самом деле довольно просто: мы просто пишем ssh и передаём

122
00:10:17,300 --> 00:10:23,460
имя пользователя, которое, как я сказал, по умолчанию root, а затем

123
00:10:23,460 --> 00:10:31,580
нам нужен вот этот символ, тот же самый, и IP-адрес или имя хоста

124
00:10:31,580 --> 00:10:37,940
удалённого сервера, к которому мы подключаемся, в нашем случае это был этот IP-адрес, и всё.

125
00:10:37,940 --> 00:10:43,700
Если выполнить, он просто спросит, хотим ли мы подключиться к

126
00:10:43,700 --> 00:10:49,420
серверу и, по сути, подтвердить подлинность этого удалённого сервера; мы подтвердим

127
00:10:49,420 --> 00:10:55,020
это, введя yes, и теперь нужно ввести пароль, то есть пройти аутентификацию

128
00:10:55,020 --> 00:11:00,140
на сервере, а пароль — тот, который мы задали при создании дроплета, так что я

129
00:11:00,140 --> 00:11:11,700
ввожу этот пароль, нажимаю Enter — и готово: теперь в своём терминале я подключился

130
00:11:11,700 --> 00:11:22,500
к терминалу удалённого сервера, поэтому здесь вы видите, что приглашение отличается от

131
00:11:22,500 --> 00:11:28,540
того, что было у меня. Снова о составе приглашения: первая часть —

132
00:11:28,540 --> 00:11:37,620
имя пользователя машины, то есть root, а это имя машины; наша

133
00:11:37,620 --> 00:11:44,140
машина называлась NanaUbuntu, и это имя удалённого сервера. Мы находимся в

134
00:11:44,140 --> 00:11:51,900
домашнем каталоге пользователя root, если сделать pwd, увидим /root; то есть мы просто

135
00:11:51,900 --> 00:11:58,740
подключились к удалённой машине с локальной с помощью аутентификации по имени пользователя и паролю,

136
00:11:58,740 --> 00:12:06,820
без использования SSH-ключей. И раз мы в терминале удалённого сервера, можем тут что-то делать,

137
00:12:06,860 --> 00:12:14,780
например устанавливать приложения, то есть делать apt install любого приложения,

138
00:12:14,780 --> 00:12:22,460
но наша цель — иметь возможность подключаться к серверу без пароля, и для этого нам

139
00:12:22,460 --> 00:12:31,180
нужно настроить пару SSH-ключей. Я открою новый терминал здесь, оставаясь

140
00:12:31,180 --> 00:12:41,540
в терминале сервера, а здесь у нас свой. Сначала в домашнем каталоге моего пользователя мы можем

141
00:12:41,540 --> 00:12:49,060
проверить, есть ли папка .ssh, и видим, что она есть; она была создана, собственно,

142
00:12:49,060 --> 00:12:59,020
когда мы подтвердили тот запрос подлинности хоста, он сохранился здесь. И теперь с помощью SSH

143
00:12:59,620 --> 00:13:07,340
подкоманды мы создадим пару SSH-ключей, что тоже очень просто: я просто выполню ssh

144
00:13:07,340 --> 00:13:19,660
keygen, или генерацию ключей, и укажу здесь флаг опции RSA. Что это за опция? Это

145
00:13:19,660 --> 00:13:26,340
тип пары ключей, которую мы создаём, а это значение — криптографический

146
00:13:26,380 --> 00:13:33,860
алгоритм, который используется для шифрования ключей. У нас есть три-четыре разных варианта, один из

147
00:13:33,860 --> 00:13:39,900
распространённых — RSA, его мы и выбираем. Но нам необязательно знать, как эти ключи

148
00:13:39,900 --> 00:13:45,460
подробно шифруются и создаются; нам нужно просто их создать и использовать. Так что я

149
00:13:45,460 --> 00:13:53,460
нажимаю ОК, и тут есть несколько параметров настройки: во-первых, где сохранить ключ.

150
00:13:53,780 --> 00:14:01,300
По умолчанию используется папка .ssh, так что мы просто подтверждаем, просто говорим

151
00:14:01,940 --> 00:14:09,700
теперь мы можем дополнительно защитить нашу пару ключей парольной фразой, поэтому даже если нам не понадобится

152
00:14:09,700 --> 00:14:17,700
пароль при подключении к удаленному, мы можем добавить себе парольную фразу, что то же самое что пароль

153
00:14:17,700 --> 00:14:24,980
для дополнительной безопасности я обычно оставляю это пустым, так что парольная фраза не нужна, и вот

154
00:14:24,980 --> 00:14:36,020
вот и все, пара ключей создана, это просто вывод, и теперь если зайдем в папку .ssh и

155
00:14:36,020 --> 00:14:45,460
выведем содержимое, вот наша пара SSH-ключей: есть публичный ключ с расширением .pub

156
00:14:45,460 --> 00:14:51,060
и есть приватный ключ, так что вот приватный, и как я сказал, приватный остается на

157
00:14:51,060 --> 00:14:56,980
компьютере, мы им ни с кем не делимся, а публичным можно поделиться с удаленным сервером

158
00:14:57,700 --> 00:15:08,500
к которому хотим подключаться. Теперь, как поместить этот публичный ключ на удаленный сервер, чтобы мы

159
00:15:08,500 --> 00:15:15,700
могли подключаться к нему с помощью SSH-ключа? Это довольно просто, потому что на этом сервере у нас

160
00:15:15,700 --> 00:15:22,900
тоже есть папка .ssh, или мы можем создать, если ее нет, и в нашем случае есть файл authorized

161
00:15:22,900 --> 00:15:31,780
keys. Давайте выведем, что внутри, и видите, он пуст, и это тот файл, authorized

162
00:15:31,780 --> 00:15:40,980
keys — это файл, куда мы добавляем публичные ключи всех компьютеров, всех клиентских

163
00:15:41,700 --> 00:15:47,380
компьютеров, которые хотят подключиться к этому серверу, так что это по сути список публичных ключей

164
00:15:48,660 --> 00:15:52,020
так что я собираюсь открыть этот файл authorized keys

165
00:15:52,180 --> 00:16:02,100
в редакторе vim, а затем просто скопирую все, что внутри публичного ключа

166
00:16:04,580 --> 00:16:13,860
и нужно сделать так: я копирую все это, целиком, и вставляю в

167
00:16:13,860 --> 00:16:22,740
сюда. Снова, это окружение моего компьютера или моих виртуальных коробок, это мой пользователь nano, где

168
00:16:22,740 --> 00:16:30,820
мы создали пару ключей, и это содержимое публичного ключа, которое я копирую и вставляю

169
00:16:31,620 --> 00:16:38,900
в файл authorized_keys удаленного сервера, правильно, и если у вас несколько людей подключаются

170
00:16:38,900 --> 00:16:46,500
к серверу, вы можете добавить эти публичные ключи списком здесь, так что давайте сохраним это и учтем, что мы

171
00:16:46,500 --> 00:16:53,620
не должны использовать sudo ни для чего из этого, потому что мы root-пользователь, отлично, так что настроено

172
00:16:54,340 --> 00:17:05,780
теперь я выйду с этого сервера, и нас выбросит обратно на нашу машину, и теперь давайте попробуем

173
00:17:05,780 --> 00:17:13,220
снова подключиться к хосту, та же команда, помните, в прошлый раз нам нужно было вводить пароль

174
00:17:13,220 --> 00:17:20,660
теперь посмотрим, что происходит, и вот, нам не пришлось вводить пароль, потому что

175
00:17:20,660 --> 00:17:28,260
приватный ключ использовался для аутентификации с сервером, потому что мы добавили наш публичный ключ в

176
00:17:28,260 --> 00:17:33,460
файл authorized_keys. Также тот запрос, который был в первый раз, тоже не появился,

177
00:17:34,100 --> 00:17:43,460
потому что тот IP-адрес сервера, вот этот, уже есть в файле known_hosts

178
00:17:45,300 --> 00:17:55,380
теперь давайте снова вернемся на наш компьютер через exit и посмотрим на эту команду ssh, которую мы

179
00:17:56,100 --> 00:18:02,900
выполнили для подключения к удаленному серверу, и вы видите, что мы не указали приватный ключ

180
00:18:04,100 --> 00:18:11,140
в опциях команды, мы просто сказали ssh, имя пользователя на удаленном сервере и IP-адрес

181
00:18:11,140 --> 00:18:19,380
удаленного сервера. Так как же она знает, какой приватный ключ использовать или где его найти? Ну, в .ssh

182
00:18:23,620 --> 00:18:24,100
id

183
00:18:24,660 --> 00:18:35,220
rsa — это на самом деле стандартное расположение, где команда ssh будет искать приватный ключ

184
00:18:35,220 --> 00:18:40,340
и это значит, что если у вас несколько пар ключей в папке .ssh и ваш приватный ключ называется

185
00:18:40,340 --> 00:18:46,660
id_rsa2 или как-то иначе, то нужно указать это явно, потому что

186
00:18:47,620 --> 00:18:56,740
стандартное расположение будет неправильным, так что эта команда здесь по сути эквивалентна

187
00:18:57,460 --> 00:19:05,620
вот этому, то есть той же команде, но с опцией передачи приватного ключа в ssh

188
00:19:05,620 --> 00:19:11,700
команде, верно, указывая расположение приватного ключа. Так что, как я сказал, если у вас несколько

189
00:19:11,700 --> 00:19:19,300
пар ключей, и для этого сервера вы используете приватный ключ с именем id_rsa2, то вам

190
00:19:19,300 --> 00:19:27,860
нужно указывать это явно вот так. Давайте попробуем выполнить это и посмотрим, что произойдет

191
00:19:27,860 --> 00:19:36,820
вот, мы успешно подключились, отлично. И в качестве финального шага мы хотим создать простой

192
00:19:36,820 --> 00:19:44,020
файл скрипта на нашем локальном компьютере, затем скопировать его на удаленный и выполнить там, так что снова

193
00:19:44,020 --> 00:19:53,780
давайте выйдем, переключаясь туда-сюда между нашим локальным и удаленным серверами и машинами

194
00:19:54,660 --> 00:20:00,020
поэтому я собираюсь создать здесь очень простой скрипт, назовем его test.sh

195
00:20:00,340 --> 00:20:17,940
строка шебанга вот так, и просто выведем что-то: я выполняюсь на удаленном сервере

196
00:20:21,060 --> 00:20:28,580
так что давайте сохраним это, и всего одной простой командой мы можем теперь скопировать этот файл

197
00:20:29,540 --> 00:20:36,020
с нашей локальной машины на удаленную, и для этого у нас есть команда scp

198
00:20:36,660 --> 00:20:44,740
что означает secure copy, и нам просто нужен источник и цель: источник — файл test.sh

199
00:20:45,460 --> 00:20:51,380
а цель — наш удаленный сервер, так что как мы указывали это для команды ssh, мы

200
00:20:51,380 --> 00:20:56,900
указываем то же самое для команды scp: имя пользователя удаленного сервера

201
00:20:59,060 --> 00:21:06,820
ip-адрес и наконец нам действительно нужен путь или расположение директории, куда

202
00:21:06,820 --> 00:21:13,940
этот файл будет скопирован на удалённую машину, и мы можем скопировать его в домашний каталог пользователя root

203
00:21:14,580 --> 00:21:23,300
вот так, и давайте выполним, и вы видите, что у нас вывод, что 100 процентов было скопировано

204
00:21:23,860 --> 00:21:31,780
и кстати эта команда также принимает приватный ключ как параметр, но по умолчанию это

205
00:21:31,780 --> 00:21:38,980
dot ssh id underscore rsa, поэтому нам не нужно указывать его здесь, однако это будет эквивалентно

206
00:21:38,980 --> 00:21:49,300
этому тоже, так что это та же самая команда, опять же, если вы используете другой

207
00:21:49,940 --> 00:21:55,380
имя приватного ключа или он в другом месте, тогда нужно явно указать его здесь

208
00:21:56,180 --> 00:22:01,620
так что теперь, когда мы скопировали файл на удалённую машину, давайте снова туда зайдём или по ssh и

209
00:22:02,500 --> 00:22:08,340
выполним этот файл, так что давайте снова выполним нашу ssh команду

210
00:22:08,820 --> 00:22:19,620
и теперь если я сделаю ls на этом удалённом сервере, вот здесь у нас есть файл task.sh и давайте

211
00:22:20,820 --> 00:22:26,820
проверим права, и вы видите, что у нас нет прав на выполнение, поэтому нам нужно отредактировать

212
00:22:28,420 --> 00:22:31,860
change mod, давайте добавим это пользователю root

213
00:22:32,420 --> 00:22:45,060
task.sh и вот, теперь просто выполняем, и вот оно

214
00:22:48,420 --> 00:22:55,860
так что это всё, что вам нужно знать об ssh и как его использовать, как я сказал, мы будем использовать ssh

215
00:22:56,420 --> 00:23:02,660
много на протяжении буткемпа, так как мы будем создавать серверы в облаке

216
00:23:02,660 --> 00:23:09,700
чтобы запускать там приложения, потому что как devops-инженер вы делаете много всего на серверах, так что вы

217
00:23:09,700 --> 00:23:16,500
будете иметь множество возможностей в течение буткемпа попрактиковаться в ssh, и одна

218
00:23:16,500 --> 00:23:22,820
вещь, о которой вы, возможно, уже спрашиваете себя, это что мы на самом деле не настроили правило файрвола, чтобы

219
00:23:22,900 --> 00:23:30,180
получить доступ к нашему серверу на digital ocean, и причина в том, что по умолчанию, когда мы создаём серверы

220
00:23:30,180 --> 00:23:37,940
здесь всё или все порты открыты, так что мы можем получить доступ к серверу или любому приложению на любом

221
00:23:37,940 --> 00:23:44,820
порту на сервере по умолчанию, так это настроено, однако у нас, конечно, есть возможность

222
00:23:44,820 --> 00:23:52,420
создать конфигурацию файрвола, затем назначить её нашему серверу и заблокировать все порты

223
00:23:52,420 --> 00:23:59,860
и просто открыть те, к которым мы хотим иметь доступ, и вы можете сделать всё это в ui здесь

224
00:23:59,860 --> 00:24:05,780
и мы собираемся изучить всё это и как настраивать файрвол в модуле основы облака

225
00:24:05,780 --> 00:24:11,780
и также, когда вы закончите с сервером, вы можете просто удалить его, чтобы у вас не было затрат

226
00:24:11,780 --> 00:24:27,700
здесь, просто перейдя в droplets и затем сделав destroy, и вот так

