1
00:00:00,000 --> 00:00:08,400
In this video, we're going to talk about version control and why do we need it?

2
00:00:08,400 --> 00:00:12,120
Let's say a typical example is you work on a project in a team.

3
00:00:12,120 --> 00:00:17,360
It could be a startup or a big project at Google, for example, or some big company.

4
00:00:17,360 --> 00:00:22,240
So let's say five developers are working on the same code of the application.

5
00:00:22,240 --> 00:00:29,040
You build frontend, Steve, another developer in your team builds backend, and Emily does

6
00:00:29,040 --> 00:00:33,760
the database connection part, they add code and so on.

7
00:00:33,760 --> 00:00:41,040
So how do you share the code among you and the team, especially when many of you work

8
00:00:41,040 --> 00:00:44,120
on the same files and make changes in the same file?

9
00:00:44,120 --> 00:00:46,240
How does this actually work?

10
00:00:46,240 --> 00:00:50,160
It works so that code is hosted centrally on internet.

11
00:00:50,160 --> 00:00:55,760
So you can all access it and the place where code lives is called code repository.

12
00:00:55,760 --> 00:01:00,880
But you aren't editing the file in the real time in the remote repository, like Google

13
00:01:00,880 --> 00:01:07,640
docs, multi collaboration, for example, also you need the code locally to start the application,

14
00:01:07,640 --> 00:01:09,680
develop stuff, and so on.

15
00:01:09,680 --> 00:01:16,040
So you fetch that code from remote repository to your local machine, do some changes and

16
00:01:16,040 --> 00:01:19,200
then push those changes back to the repository.

17
00:01:19,200 --> 00:01:25,720
So the next developer can fetch it on their computer and make his or her changes.

18
00:01:25,720 --> 00:01:34,440
So all developers just push and pull changes in and from this code repository.

19
00:01:34,440 --> 00:01:39,640
What happens when you and Emily, for example, change the same files?

20
00:01:39,640 --> 00:01:44,600
Git knows how to merge most of the changes in the same files.

21
00:01:44,600 --> 00:01:50,960
So when you fetch the code that has the changes in the same files that you have changed locally,

22
00:01:50,960 --> 00:01:57,040
it will help you merge those changes before you push yours to the repository.

23
00:01:57,040 --> 00:02:04,720
But what happens if you edit files for days and the same time Emily changes the same files

24
00:02:04,720 --> 00:02:07,480
in completely different direction, right?

25
00:02:07,480 --> 00:02:13,320
So this changes will be so different that Git won't be able to sort this out, right?

26
00:02:13,320 --> 00:02:19,960
So that maybe the same exact locations in that file have been updated.

27
00:02:19,960 --> 00:02:24,800
So Git doesn't know do you want your changes or changes of Emily, right?

28
00:02:24,800 --> 00:02:27,520
So these are called conflicts.

29
00:02:27,520 --> 00:02:33,440
And in this case, you will have to go to Emily and then manually try to sort how the end

30
00:02:33,440 --> 00:02:35,000
result should look like.

31
00:02:35,000 --> 00:02:40,360
So maybe communicate, what did you change here, how we can adjust the code so that both of

32
00:02:40,360 --> 00:02:42,800
our changes make sense.

33
00:02:42,800 --> 00:02:44,980
And that sounds tedious.

34
00:02:44,980 --> 00:02:52,220
Because of that best practice in development, when working in a bigger team of developers

35
00:02:52,220 --> 00:02:57,900
that work on the same code, the best practice is to keep pushing and pulling often from

36
00:02:57,900 --> 00:02:58,900
the repository.

37
00:02:58,900 --> 00:03:04,060
So Git doesn't have to merge huge changes that overlap too much.

38
00:03:04,060 --> 00:03:09,420
And you can also easily sort those different changes out.

39
00:03:09,420 --> 00:03:13,020
This is called continuous integration.

40
00:03:13,020 --> 00:03:18,420
Simply integrating your code changes frequently in the repository.

41
00:03:18,420 --> 00:03:24,100
Now what happens if someone messes code up and the changes break the application?

42
00:03:24,100 --> 00:03:29,620
So for example, you have a new junior developer and he accidentally checks in some changes

43
00:03:29,620 --> 00:03:34,820
to the repository that doesn't compile so you cannot start the application.

44
00:03:34,820 --> 00:03:39,140
So nothing works and runs and everybody's blocked.

45
00:03:39,140 --> 00:03:45,140
First of all, when someone pushes their breaking changes to the repository, the breaking changes

46
00:03:45,140 --> 00:03:47,700
could be an official term for this.

47
00:03:47,700 --> 00:03:53,060
It doesn't affect you until you pull these changes from the remote repository.

48
00:03:53,060 --> 00:03:58,180
Because you are working with your local copy of that repository.

49
00:03:58,180 --> 00:04:03,420
But once you pull those changes, you have the breaking changes too.

50
00:04:03,420 --> 00:04:05,460
But no need to panic.

51
00:04:05,460 --> 00:04:10,820
Version control keeps the history of the changes to the repository.

52
00:04:10,820 --> 00:04:16,460
So every code change in every file is tracked in Git.

53
00:04:16,460 --> 00:04:21,100
So every change commit by a dev member is a new history item.

54
00:04:21,100 --> 00:04:26,100
And the good thing is that you can revert the commits or you can simply go back to the

55
00:04:26,100 --> 00:04:29,700
previous version of the repository anytime.

56
00:04:29,700 --> 00:04:32,940
That's where the name version control comes from.

57
00:04:32,940 --> 00:04:37,740
So as code develops, you don't have to worry about losing the track of what changes have

58
00:04:37,740 --> 00:04:40,700
happened to specific files.

59
00:04:40,700 --> 00:04:44,740
And also each change is labeled with commit messages.

60
00:04:44,740 --> 00:04:52,780
So you also know why you or someone else made those changes for future reference.

61
00:04:52,780 --> 00:04:57,500
Which naturally means that your commits shouldn't be too large.

62
00:04:57,500 --> 00:05:00,580
So that it's easily reversible, first of all.

63
00:05:00,580 --> 00:05:03,860
And also can be easily described with a commit message.

