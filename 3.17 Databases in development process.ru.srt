1
00:00:00,000 --> 00:00:06,360
Приложения используют базы данных для сохранения данных.

2
00:00:06,360 --> 00:00:12,800
Давайте посмотрим, как база данных интегрируется во весь процесс разработки ПО.

3
00:00:12,800 --> 00:00:18,280
Предположим, вы команда из пяти разработчиков, создающих Java-приложение, у которого есть UI,

4
00:00:18,280 --> 00:00:22,560
где пользователи могут создавать вещи, обновлять, удалять их и т.д.

5
00:00:22,560 --> 00:00:27,360
И все это нужно сохранять в базе данных, чтобы когда пользователи возвращались,

6
00:00:27,360 --> 00:00:28,840
данные были на месте.

7
00:00:28,840 --> 00:00:34,240
Поэтому вы подключаете базу данных к своему Java-приложению, например, это может быть база MySQL.

8
00:00:34,240 --> 00:00:41,320
Ваше Java-приложение будет отправлять запросы в базу MySQL, чтобы создавать, обновлять или удалять

9
00:00:41,320 --> 00:00:42,320
вещи.

10
00:00:42,320 --> 00:00:48,560
Когда вы разрабатываете локально, добавляете фичи, тестируете их и т.д., вам понадобится база

11
00:00:48,560 --> 00:00:50,240
для разработки.

12
00:00:50,240 --> 00:00:54,160
Как настроить это как разработчик?

13
00:00:54,160 --> 00:00:58,000
Первый вариант — у вас база данных установлена локально.

14
00:00:58,000 --> 00:01:05,480
В этом случае с нашим Java+MySQL приложением каждый разработчик в команде установит MySQL

15
00:01:05,480 --> 00:01:11,680
локально на свою машину, а затем подключит Java-приложение к этому локально

16
00:01:11,680 --> 00:01:13,440
установленному MySQL.

17
00:01:13,440 --> 00:01:16,240
В этом случае вы начинаете с пустой базы данных.

18
00:01:16,240 --> 00:01:21,160
И пока вы тестируете приложение, вы создаете сущности, добавляете данные.

19
00:01:21,160 --> 00:01:25,720
Так что у каждого разработчика будет своя база данных со своими тестовыми данными.

20
00:01:25,720 --> 00:01:31,400
Каждый из них не может испортить чужие тестовые данные, и вы можете смело пробовать

21
00:01:31,400 --> 00:01:37,480
новое, обновлять базу, выполнять SQL-скрипты, не ломая

22
00:01:37,480 --> 00:01:39,640
ничего никому.

23
00:01:39,640 --> 00:01:43,880
А если получите грязное состояние, например, можете просто очистить базу и начать

24
00:01:43,880 --> 00:01:45,380
с нуля.

25
00:01:45,380 --> 00:01:51,000
Однако недостаток в том, что, как я сказал, вы начинаете с пустой базы, и, возможно, если

26
00:01:51,000 --> 00:01:56,880
вам нужны реалистичные тестовые данные, их нужно вручную настроить или, возможно, выполнить

27
00:01:56,880 --> 00:02:00,640
скрипт, чтобы сгенерировать эти данные в базе.

28
00:02:00,640 --> 00:02:05,320
И, конечно, очевидный недостаток в том, что вам нужно установить и настроить базу

29
00:02:05,320 --> 00:02:08,040
локально на компьютере.

30
00:02:08,040 --> 00:02:12,520
Каждому разработчику придется это делать.

31
00:02:12,520 --> 00:02:19,920
Второй вариант для локальной разработки с базой — база размещена удаленно,

32
00:02:19,920 --> 00:02:26,920
и вы можете обращаться к ней по endpoint из приложения, которое работает на вашем компьютере.

33
00:02:26,920 --> 00:02:30,000
Преимущество в том, что не нужно устанавливать ее локально.

34
00:02:30,000 --> 00:02:34,680
Можно сразу начать писать код, потому что вам нужен только endpoint и учетные данные, не

35
00:02:34,680 --> 00:02:39,320
нужно запускать базу каждый раз, когда вы стартуете приложение, когда перезагружаете

36
00:02:39,320 --> 00:02:41,960
компьютер и т.д.

37
00:02:41,960 --> 00:02:46,000
И вы получаете данные сразу, не нужно их импортировать, не нужно создавать

38
00:02:46,000 --> 00:02:50,240
их самому, тестовые данные уже доступны.

39
00:02:50,240 --> 00:02:57,160
Недостаток в том, что вы не можете играться с ней, не затрагивая других, потому что

40
00:02:57,160 --> 00:03:00,760
каждый разработчик будет использовать ту же удаленную базу.

41
00:03:00,760 --> 00:03:03,880
Это, конечно, будет dev или test база.

42
00:03:03,880 --> 00:03:08,200
Но все равно вы будете влиять на тестовые данные друг друга.

43
00:03:08,200 --> 00:03:13,800
Например, когда разрабатываете в feature-ветке и делаете изменения в базе

44
00:03:14,040 --> 00:03:18,480
миграционными скриптами: добавляете столбец в существующую таблицу,

45
00:03:18,480 --> 00:03:24,000
удаляете столбец из существующей таблицы и делаете другие изменения, тогда вы

46
00:03:24,000 --> 00:03:29,120
вероятно сломаете код, и приложение не запустится, и другие разработчики будут заблокированы.

47
00:03:29,120 --> 00:03:34,040
Так что нужно аккуратно вносить изменения при использовании общей удаленной базы.

48
00:03:34,040 --> 00:03:40,080
Идеальным решением могло бы быть иметь оба: локальную базу разработки для каждого разработчика

49
00:03:40,240 --> 00:03:44,640
и удаленную в случае, если нужно протестировать на реальных данных.

50
00:03:44,640 --> 00:03:49,520
Так что у вас, по сути, есть выбор, что использовать, в зависимости от того, что вы делаете.

51
00:03:49,520 --> 00:03:51,440
Так что вы можете переключаться туда-сюда.

52
00:03:51,440 --> 00:03:55,920
И как же ваше приложение на самом деле общается с базой данных?

53
00:03:55,920 --> 00:03:59,080
Где вы это настраиваете в своем коде?

54
00:03:59,080 --> 00:04:03,640
Особенно если у вас две базы данных и вы можете при необходимости переключаться между ними, как

55
00:04:03,640 --> 00:04:05,000
вы это настраиваете?

56
00:04:05,000 --> 00:04:09,040
Подключение к базе данных, так сказать, настраивается в коде.

57
00:04:09,040 --> 00:04:15,360
У вас есть часть, где ваше приложение, ваше Java-приложение подключается к базе данных

58
00:04:15,360 --> 00:04:21,240
и у каждого языка программирования есть библиотека, которая умеет разговаривать с базой данных.

59
00:04:21,240 --> 00:04:25,200
И для каждой базы данных есть своя библиотека.

60
00:04:25,200 --> 00:04:30,320
Например, есть библиотека, которая позволяет Java общаться с MySQL.

61
00:04:30,320 --> 00:04:34,160
Есть библиотека, которая позволяет Java общаться с базой данных MongoDB.

62
00:04:34,160 --> 00:04:38,840
Точно так же есть библиотеки или модули, как их называют, для Node.js, чтобы общаться с

63
00:04:38,840 --> 00:04:40,760
MongoDB и MySQL.

64
00:04:40,760 --> 00:04:46,240
Поэтому разработчики найдут эту библиотеку и напишут код с ее использованием, чтобы подключиться к

65
00:04:46,240 --> 00:04:48,080
базе данных.

66
00:04:48,080 --> 00:04:54,360
Но вам нужно указать этой библиотеке, с какой базой данных общаться и как в ней аутентифицироваться.

67
00:04:54,360 --> 00:04:55,800
в этой базе данных.

68
00:04:55,800 --> 00:05:01,960
Поэтому если у вас есть локальная и удаленная базы данных MySQL для разработки, вам нужно указать библиотеке,

69
00:05:01,960 --> 00:05:03,680
к какой обращаться.

70
00:05:03,680 --> 00:05:07,840
Это конечная точка базы данных или ее адрес.

71
00:05:07,840 --> 00:05:12,640
И эти базы данных будут защищены именем пользователя и паролем.

72
00:05:12,640 --> 00:05:16,520
Поэтому вы должны передать эти учетные данные библиотеке.

73
00:05:16,520 --> 00:05:22,080
Используя конечную точку и учетные данные, ваше приложение может установить соединение

74
00:05:22,080 --> 00:05:23,640
когда это нужно.

75
00:05:23,640 --> 00:05:27,000
Вот как все это выглядит в коде.

76
00:05:27,000 --> 00:05:35,240
В коде Java-приложения у вас есть место, где вы определяете или настраиваете подключение,

77
00:05:35,240 --> 00:05:38,560
конечную точку и учетные данные к MySQL.

78
00:05:38,560 --> 00:05:46,360
А вот пример Node.js, где он подключается к MongoDB, используя модуль для базы данных MongoDB.

79
00:05:46,360 --> 00:05:47,440
базы данных.

80
00:05:47,440 --> 00:05:54,240
Однако по лучшим практикам не следует жестко прописывать эти значения в коде, а лучше определить

81
00:05:54,240 --> 00:06:00,640
их в одном месте как переменные окружения, чтобы настраивать их извне.

82
00:06:00,640 --> 00:06:05,300
Так что если вы хотите переключить конечную точку MySQL, нам не нужно переписывать код.

83
00:06:05,300 --> 00:06:10,120
Или прежде всего искать точное место в коде, где определена эта конечная точка, и

84
00:06:10,120 --> 00:06:16,360
затем переписывать его, а просто задать другую конечную точку и учетные данные в конфигурационном файле.

85
00:06:16,360 --> 00:06:22,040
И еще одна причина, почему лучше настраивать это извне, а не в коде

86
00:06:22,040 --> 00:06:27,520
напрямую, в том что обычно у вас есть базы данных для разработки, теста и продакшена.

87
00:06:27,520 --> 00:06:33,400
Поэтому в зависимости от того, где работает ваше приложение, оно будет подключаться к разной базе данных.

88
00:06:33,400 --> 00:06:38,380
Например, если ваше приложение работает на продакшн-сервере, конечно, оно должно

89
00:06:38,380 --> 00:06:42,200
общаться с продакшн-базой, а не с тестовой, верно?

90
00:06:42,200 --> 00:06:46,360
И у каждой будут свои конечные точки и учетные данные.

91
00:06:46,360 --> 00:06:49,560
Продакшн-база данных опять же будет гораздо лучше защищена.

92
00:06:49,560 --> 00:06:55,520
И если вы жестко прописали значения в коде, как вы будете менять их в зависимости от среды приложения

93
00:06:55,520 --> 00:06:56,520
окружения?

94
00:06:56,520 --> 00:07:01,880
С конфигурационным файлом вы просто определяете переменную в коде, как плейсхолдер,

95
00:07:01,880 --> 00:07:06,280
и задаете конечную точку извне для каждой среды.

96
00:07:06,280 --> 00:07:12,040
И также вам не следует коммитить учетные данные для базы данных в репозиторий кода, а

97
00:07:12,040 --> 00:07:16,480
передавать их при запуске приложения из соображений безопасности.

98
00:07:16,480 --> 00:07:21,640
Так что способ настроить эти значения — через переменные окружения, как я уже упоминал,

99
00:07:21,640 --> 00:07:27,240
и вы можете передавать переменные окружения при запуске как параметры через переменные

100
00:07:27,240 --> 00:07:28,240
окружения.

101
00:07:28,240 --> 00:07:33,600
И, конечно, вы можете передавать эти переменные окружения при запуске в виде параметров из

102
00:07:33,600 --> 00:07:39,080
командной строки, например, или из редактора в IntelliJ при локальном запуске.

103
00:07:39,080 --> 00:07:44,080
Но это очень непрактично, потому что, во-первых, всем придется настраивать это в

104
00:07:44,080 --> 00:07:45,460
своем редакторе.

105
00:07:45,460 --> 00:07:49,280
И еще нужно помнить, какие параметры требуются приложению.

106
00:07:49,280 --> 00:07:54,960
Во-вторых, если у вас несколько таких внешне настраиваемых значений, будет довольно хаотично

107
00:07:54,960 --> 00:07:59,280
передавать их все через командную строку или в редакторе.

108
00:07:59,280 --> 00:08:05,640
Поэтому альтернативой, или фактическим решением для этого, являются файлы свойств или конфигурационный

109
00:08:05,640 --> 00:08:07,320
файл для приложения.

110
00:08:07,320 --> 00:08:12,200
Например, в приложении на Java Spring это будет файл spring properties, который

111
00:08:12,200 --> 00:08:15,040
можно определить для каждого окружения.

112
00:08:15,040 --> 00:08:18,160
То есть для каждого окружения есть свой собственный файл свойств.

113
00:08:18,160 --> 00:08:22,600
И мы можем задать все значения, которые нам нужны, в этих файлах свойств.

114
00:08:22,600 --> 00:08:28,520
Затем Java-приложение может ссылаться на значения в этом файле свойств прямо из кода

115
00:08:28,520 --> 00:08:29,520
самого приложения.

116
00:08:29,520 --> 00:08:35,240
То есть мы можем сказать Java при запуске, какой из этих файлов свойств оно должно фактически взять.

117
00:08:35,240 --> 00:08:39,520
А для JavaScript, например, в Node.js, это будет конфигурационный файл, возможно config

118
00:08:39,520 --> 00:08:42,440
JSON или config JS.

119
00:08:42,440 --> 00:08:46,200
И, конечно, как всегда, любой другой язык программирования будет иметь что-то сопоставимое с

120
00:08:46,200 --> 00:08:47,200
этим.

121
00:08:47,200 --> 00:08:52,680
И с файлом, где все значения можно сгруппировать, все намного чище, прозрачнее,

122
00:08:52,680 --> 00:08:58,160
можно добавить множество значений, все, что вы хотите настроить в зависимости от окружения.

123
00:08:58,160 --> 00:09:02,560
Некоторые вещи, которые вы также можете добавить в эти конфигурационные файлы, это, например, уровень

124
00:09:02,560 --> 00:09:03,560
логирования, верно?

125
00:09:03,560 --> 00:09:08,280
Когда вы разрабатываете локально, вам может понадобиться логировать чуть больше о приложении,

126
00:09:08,280 --> 00:09:09,360
например режим отладки.

127
00:09:09,360 --> 00:09:14,560
Например, если приложение работает в продакшене, вы можете захотеть логировать только предупреждения

128
00:09:14,560 --> 00:09:15,840
и ошибки.

129
00:09:15,840 --> 00:09:21,040
То есть вы можете задать это исходя из окружения: endpoint базы данных и учетные данные, как мы сказали,

130
00:09:21,040 --> 00:09:26,480
и вдобавок приложения очень часто общаются с множеством других приложений.

131
00:09:26,480 --> 00:09:32,040
Если это микросервисное приложение, то микросервисы будут общаться друг с другом через какой-то

132
00:09:32,040 --> 00:09:35,880
шину сервисов или, возможно, какое-то приложение для обмена сообщениями.

133
00:09:35,880 --> 00:09:43,440
Так что все эти endpoints приложений или сервисов, с которыми приложение должно

134
00:09:43,440 --> 00:09:48,480
общаться, вместе с их учетными данными, будут настроены здесь.

135
00:09:48,480 --> 00:09:54,120
И это практично, потому что вы точно знаете, где искать и менять эти endpoints,

136
00:09:54,120 --> 00:09:55,560
если нужно их поправить.

137
00:09:55,560 --> 00:09:57,840
Все определено в одном месте.

138
00:09:57,840 --> 00:09:58,840
Так что круто.

139
00:09:58,840 --> 00:10:04,160
Теперь мы знаем, как базы данных должны использоваться в локальной разработке и как мы можем настроить

140
00:10:04,160 --> 00:10:07,800
подключение к любой базе данных из любого приложения.

141
00:10:07,800 --> 00:10:12,520
Теперь предположим, что первая версия приложения готова, и нам нужно запустить ее на продакшн

142
00:10:12,520 --> 00:10:13,520
сервере.

143
00:10:13,520 --> 00:10:17,400
Очевидно, приложению понадобится база данных, чтобы работать.

144
00:10:17,400 --> 00:10:23,200
Поэтому перед тем как деплоить приложение, нам нужно установить и настроить базу данных для продакшн

145
00:10:23,200 --> 00:10:24,200
окружения.

146
00:10:24,200 --> 00:10:29,360
Опять же, либо на том же сервере, где будет работать приложение, либо на отдельно

147
00:10:29,360 --> 00:10:32,280
управляемом сервере, удаленной базе данных.

148
00:10:32,280 --> 00:10:37,680
И как только база данных работает, мы можем задеплоить приложение, и оно подключится к ней

149
00:10:37,680 --> 00:10:42,400
при запуске с endpoint и учетными данными из файла свойств.

150
00:10:42,400 --> 00:10:46,560
Так как же это на самом деле делается в продакшене в реальных проектах?

151
00:10:46,560 --> 00:10:51,920
Потому что данные настолько важны и ценны в большинстве приложений, например, если подумать

152
00:10:51,920 --> 00:10:57,320
о Facebook или LinkedIn, очевидно, вы не хотите потерять данные пользователей,

153
00:10:57,320 --> 00:11:02,000
и вы хотите реплицировать их и создавать резервные копии максимально хорошо.

154
00:11:02,000 --> 00:11:07,240
Поэтому нужно делать регулярные бэкапы и убедиться, что всё работает под нагрузкой, когда

155
00:11:07,240 --> 00:11:13,640
многие пользователи обращаются к приложению, чтобы база данных выдерживала все подключения.

156
00:11:13,640 --> 00:11:19,040
И все эти процессы, как резервное копирование базы данных, репликация, обеспечение того,

157
00:11:19,040 --> 00:11:22,680
что всё работает плавно, — важная и сложная задача.

158
00:11:22,680 --> 00:11:27,280
Поэтому есть отдельная роль для управления базами данных в проекте.

159
00:11:27,280 --> 00:11:32,200
Обычно это системный администратор, инженер по базам данных или DevOps-инженер.

160
00:11:32,200 --> 00:11:37,960
Поэтому сами разработчики обычно не управляют базами данных, особенно теми, которые

161
00:11:37,960 --> 00:11:40,080
используются в продакшене.

162
00:11:40,080 --> 00:11:45,680
И конечно, в крупных проектах и компаниях у вас будут отдельные команды, управляющие базами данных

163
00:11:45,680 --> 00:11:51,960
и аккуратно выдающие доступ разработчикам к стендовым и продакшн-базам.

164
00:11:51,960 --> 00:11:54,600
В небольших проектах, конечно, всё менее строго.

165
00:11:54,600 --> 00:12:00,440
Так что, возможно, разработчики имеют прямой доступ к базе данных, а в некоторых случаях она может даже

166
00:12:00,440 --> 00:12:04,280
работать на том же сервере, что и само приложение.

167
00:12:04,280 --> 00:12:12,560
В целом, что вам, как DevOps-инженеру, нужно знать о базах данных: как их настраивать,

168
00:12:12,560 --> 00:12:18,640
как их поднимать и управлять ими, включая репликацию, регулярные

169
00:12:18,640 --> 00:12:19,800
резервные копии.

170
00:12:19,800 --> 00:12:25,480
И если что-то случится с сервисами базы данных, уметь восстановить саму базу.

171
00:12:25,480 --> 00:12:30,200
Кроме того, полезно понимать, как обычно настраивается подключение между

172
00:12:30,200 --> 00:12:36,400
приложением и базами данных со стороны разработчиков.

173
00:12:36,400 --> 00:12:42,040
Теперь вы понимаете, как базы данных работают в связке с приложением.

174
00:12:42,040 --> 00:12:47,920
Мы увидим базы данных в действии в модуле про контейнеры, в котором мы изучим Docker, где мы

175
00:12:47,920 --> 00:12:54,000
подключим наше приложение к базе данных через properties или конфиг и запустим

176
00:12:54,000 --> 00:12:54,960
на удалённом сервере.

