1
00:00:00,000 --> 00:00:08,720
В мире баз данных существуют разные типы БД, которые появились и

2
00:00:08,720 --> 00:00:10,320
все еще появляются.

3
00:00:10,320 --> 00:00:17,680
Вы могли слышать их названия, такие как CassandraDB, InflexDB, MongoDB, Cockroach, DB, Elasticsearch,

4
00:00:17,680 --> 00:00:24,480
Redis, Memcached и более популярные, с которыми вы, вероятно, уже работали, такие как MySQL,

5
00:00:24,480 --> 00:00:28,040
Postgres, Oracle, DB и т.д.

6
00:00:28,040 --> 00:00:32,920
Так почему существует так много баз данных и чем они отличаются?

7
00:00:32,920 --> 00:00:39,800
И какую из них мне использовать для своего приложения или стоит использовать несколько сразу?

8
00:00:39,800 --> 00:00:45,520
В этом видео мы рассмотрим эти разные типы баз данных и объясним, когда использовать

9
00:00:45,520 --> 00:00:48,000
каждую.

10
00:00:48,000 --> 00:00:53,800
Первый тип и, вероятно, самый простой — базы данных KeyValue.

11
00:00:53,800 --> 00:00:58,960
Другие примеры — Redis, Memcached и HCD из Kubernetes.

12
00:00:58,960 --> 00:01:05,400
Каждая пара ключ-значение в базе KeyValue похожа на объект JavaScript.

13
00:01:05,400 --> 00:01:10,160
Каждый ключ уникален и указывает на конкретное значение.

14
00:01:10,160 --> 00:01:16,400
Вы можете записывать данные, добавляя пару ключ-значение, и читать данные по ключу.

15
00:01:16,400 --> 00:01:22,320
Модель данных очень простая, поэтому тут нет join или других сложных концепций из реляционных

16
00:01:22,320 --> 00:01:26,800
баз данных, например, но такие базы очень быстрые.

17
00:01:26,800 --> 00:01:27,800
Почему?

18
00:01:27,800 --> 00:01:32,000
Потому что Redis и Memcached, например, хранят все свои данные в памяти в отличие от

19
00:01:32,000 --> 00:01:37,400
большинства традиционных баз данных, которые сохраняют данные на жестком диске.

20
00:01:37,400 --> 00:01:43,440
Это значит, что вы не можете хранить много данных, потому что объем памяти ограничен, но доступ

21
00:01:43,440 --> 00:01:45,480
к данным происходит очень быстро.

22
00:01:45,480 --> 00:01:51,320
И это также означает, что такие базы данных не подходят как основная база для вашего

23
00:01:51,320 --> 00:01:57,360
приложения, где нужна долгосрочная сохранность данных, а скорее используются как

24
00:01:57,360 --> 00:02:02,520
кэш, чтобы сделать приложение быстрее и более «реальным временем».

25
00:02:02,520 --> 00:02:09,800
Например, Twitter и Snapchat и некоторые другие подобные приложения используют Redis для потоковой

26
00:02:09,800 --> 00:02:14,200
доставки данных, чтобы сделать приложение быстрее.

27
00:02:14,200 --> 00:02:19,960
Иногда его также используют как очередь сообщений для некоторых брокеров сообщений,

28
00:02:19,960 --> 00:02:29,160
но в основном как кэш-базу поверх другой основной базы, которая сохраняет данные долгосрочно.

29
00:02:29,160 --> 00:02:34,960
И как я упомянул, в начале HCD — тоже одна из таких баз, которая используется в Kubernetes

30
00:02:34,960 --> 00:02:37,840
для хранения состояния кластера в реальном времени.

31
00:02:37,840 --> 00:02:45,400
Так что каждое малейшее изменение в кластере Kubernetes, связанное с любым компонентом, сразу

32
00:02:45,400 --> 00:02:50,440
обновляется в хранилище HCD, поэтому оно тоже должно быть быстрым.

33
00:02:50,440 --> 00:02:55,440
Второй тип баз данных — это широкие колоночные базы данных.

34
00:02:55,440 --> 00:03:02,480
Теперь базы данных ключ-значение, как вы уже догадались, довольно ограничены по схеме.

35
00:03:02,480 --> 00:03:07,640
С ключ-значение структурами не так много можно сделать.

36
00:03:07,640 --> 00:03:14,040
Поэтому, если нужно хранить более сложные данные ключ-значение, колоночные базы — альтернатива.

37
00:03:14,040 --> 00:03:19,360
Ключ тот же, но значение делится на несколько колонок вместо одной

38
00:03:19,360 --> 00:03:21,240
колонки.

39
00:03:21,240 --> 00:03:27,800
Популярные реализации колоночных баз — Cassandra и Apache HBase.

40
00:03:27,800 --> 00:03:33,800
В отличие от реляционных баз данных, у них нет предопределенной схемы, поэтому можно иметь любое количество

41
00:03:33,800 --> 00:03:36,280
колонок любого типа данных.

42
00:03:36,280 --> 00:03:43,680
Это значит, что они могут работать с неструктурированными данными с динамическим числом колонок на ключ.

43
00:03:43,680 --> 00:03:49,320
Они также очень масштабируемы и легко распределяются по нескольким серверам.

44
00:03:49,320 --> 00:03:53,200
Их язык запросов очень похож на SQL, но намного проще.

45
00:03:53,200 --> 00:03:59,760
Также здесь нет join или похожих сложных концепций из реляционных баз данных, что

46
00:03:59,760 --> 00:04:06,280
делает их более простым типом баз, но и более ограниченным в сравнении.

47
00:04:06,280 --> 00:04:13,160
Итак, их основной сценарий — обработка больших объемов неструктурированных данных, чаще всего для

48
00:04:13,160 --> 00:04:20,040
данных временных рядов, например записей с IoT-устройств, таких как умные автомобили и датчики и т.д.

49
00:04:20,040 --> 00:04:24,840
Поэтому, как и базы ключ-значение, их следует использовать поверх основной базы данных

50
00:04:24,840 --> 00:04:31,640
для случаев вроде хранения истории событий или данных временных рядов, как я упомянул ранее.

51
00:04:31,640 --> 00:04:39,120
И если вам нужно что-то более общего назначения, то третий тип баз данных — это

52
00:04:39,120 --> 00:04:42,400
документо-ориентированные базы данных.

53
00:04:42,400 --> 00:04:49,200
LongDB, DynamoDB, CouchDB — некоторые популярные реализации документо-ориентированных

54
00:04:49,200 --> 00:04:55,240
баз данных, и здесь у вас есть документы, которые являются контейнерами для пар ключ-значение.

55
00:04:55,240 --> 00:05:01,080
Это тоже неструктурированные данные, поэтому вам не нужно создавать схему, прежде чем добавлять

56
00:05:01,080 --> 00:05:02,720
данные.

57
00:05:02,720 --> 00:05:08,440
Документы группируются в коллекции, а коллекции можно организовывать в реляционную

58
00:05:08,440 --> 00:05:10,000
иерархию.

59
00:05:10,000 --> 00:05:16,640
Это немного имитирует модель реляционной базы данных, но здесь по-прежнему нет соединений

60
00:05:16,640 --> 00:05:17,840
и здесь тоже.

61
00:05:17,840 --> 00:05:23,280
По сравнению с реляционной базой данных обновления выполняются медленнее, потому что данные здесь могут быть вложенными

62
00:05:23,280 --> 00:05:28,640
в иерархии документов, поэтому сложнее обновлять небольшие части данных внутри

63
00:05:28,640 --> 00:05:34,040
документов, но чтение данных быстрее, потому что данные уже структурированы как

64
00:05:34,040 --> 00:05:38,340
коллекция всей связанной информации в одном документе.

65
00:05:38,340 --> 00:05:44,060
Поэтому нет необходимости собирать их, читая несколько таблиц, как вы бы делали в нормализованной

66
00:05:44,060 --> 00:05:46,500
реляционной базе данных.

67
00:05:46,500 --> 00:05:50,980
Это довольно интуитивно для разработчиков, и также очень легко

68
00:05:50,980 --> 00:05:54,500
начать использовать и применять в вашем приложении.

69
00:05:54,500 --> 00:06:01,180
Некоторые варианты использования: мобильные приложения, игры, управление контентом

70
00:06:01,180 --> 00:06:06,580
— это отличный вариант применения, и множество других случаев, потому что, как я сказал, это

71
00:06:06,580 --> 00:06:11,180
гораздо более общего назначения, чем колоночные или базы данных ключ-значение.

72
00:06:11,180 --> 00:06:13,380
Так что вы можете использовать его для большего числа задач.

73
00:06:13,380 --> 00:06:20,820
И по сравнению с колоночными и базами данных ключ-значение это может фактически использоваться как основная база данных

74
00:06:20,820 --> 00:06:22,980
для данных вашего приложения.

75
00:06:22,980 --> 00:06:25,520
И, как я упоминал, она без схемы.

76
00:06:25,520 --> 00:06:30,100
Поэтому, если вы не знаете, как будут структурированы ваши данные и каким в итоге окажется их

77
00:06:30,100 --> 00:06:36,060
вид, так сказать, то это тоже очень хорошо подходит, потому что можно начать без

78
00:06:36,060 --> 00:06:37,060
схемы.

79
00:06:37,060 --> 00:06:43,700
Где его не следует использовать: если у вас куча взаимосвязанных данных, как графы

80
00:06:43,700 --> 00:06:49,500
которые требуют частых обновлений; примером могут быть приложения социальных сетей

81
00:06:49,500 --> 00:06:54,060
где у пользователей есть друзья, а у них есть публикации и комментарии.

82
00:06:54,060 --> 00:07:00,380
Все эти элементы данных или записи связаны и коррелируют друг с другом.

83
00:07:00,380 --> 00:07:05,660
Это не лучший вариант для документно-ориентированных баз данных.

84
00:07:05,660 --> 00:07:11,180
Для таких случаев, когда вещи взаимосвязаны и связаны во множестве разных направлений,

85
00:07:11,180 --> 00:07:13,380
существует тип реляционных баз данных.

86
00:07:13,380 --> 00:07:19,260
MySQL, PostgreSQL — некоторые реализации реляционных баз данных.

87
00:07:19,260 --> 00:07:25,300
Реляционные базы данных — самые широко используемые и популярные и существуют уже долгое

88
00:07:25,300 --> 00:07:26,300
время.

89
00:07:26,300 --> 00:07:28,720
Это структурированная база данных.

90
00:07:28,720 --> 00:07:37,040
Поэтому вы можете использовать ее для хранения неструктурированных данных, и требуется строгая схема заранее.

91
00:07:37,040 --> 00:07:41,960
Поэтому, прежде чем записывать что-либо в базу, нужно сначала создать схему того, как

92
00:07:41,960 --> 00:07:47,360
будут выглядеть данные, сколько атрибутов будет, какие атрибуты, какие типы данных

93
00:07:47,360 --> 00:07:53,440
у них будут, а также как будут выглядеть значения, собственно значения, например

94
00:07:53,440 --> 00:08:00,560
максимальный размер, числовое значение или максимальный размер символов, необязательное оно или обязательное.

95
00:08:00,560 --> 00:08:04,280
По сути, все это нужно определить заранее.

96
00:08:04,280 --> 00:08:09,540
И поскольку она используется для структурированных данных, ее формат запросов называется структурированный язык

97
00:08:09,540 --> 00:08:16,040
запросов или SQL для чтения и записи в базу данных.

98
00:08:16,040 --> 00:08:21,840
Так что же такое реляционная база данных и как она выглядит?

99
00:08:21,840 --> 00:08:29,000
В реляционной базе данных данные организованы в таблицы, которые имеют строки и столбцы.

100
00:08:29,000 --> 00:08:36,520
Например, допустим, у нас есть приложение с пользователями, которые пишут комментарии к постам

101
00:08:36,520 --> 00:08:40,660
другими пользователями, которые тоже публикуют свои посты.

102
00:08:40,660 --> 00:08:47,000
Так что каждая из этих сущностей, так сказать, будет храниться отдельно в таблицах, каждая

103
00:08:47,000 --> 00:08:49,640
идентифицируется уникальным ID.

104
00:08:49,640 --> 00:08:54,440
У вас будут ID пользователей, ID комментариев, ID постов и так далее.

105
00:08:54,440 --> 00:09:00,680
Но мы не можем связать комментарий или пост с пользователем без ссылки, верно?

106
00:09:00,680 --> 00:09:08,720
Поэтому комментарии будут ссылаться на пользователя, написавшего комментарий, используя ID пользователя.

107
00:09:08,720 --> 00:09:13,520
Комментарии также будут ссылаться на пост, к которому они относятся, используя ID поста.

108
00:09:13,520 --> 00:09:17,800
И посты тоже будут ссылаться на пользователя, который их опубликовал, через ID пользователя.

109
00:09:17,800 --> 00:09:19,920
То есть они все связаны.

110
00:09:19,920 --> 00:09:25,680
Почему бы нам просто не свалить их всех в одну большую таблицу, вы, возможно, спросите сейчас.

111
00:09:25,680 --> 00:09:30,520
Так мы избегаем повторения значений снова и снова.

112
00:09:30,520 --> 00:09:37,040
Например, если пользователь пишет 1000 комментариев и постов, мы не хотим добавлять всю информацию о пользователе

113
00:09:37,040 --> 00:09:42,840
типа имени пользователя, email, пароля, возможно адреса и прочих данных, которые мы собрали

114
00:09:42,840 --> 00:09:47,560
о пользователе, к каждому посту и каждому комментарию.

115
00:09:47,560 --> 00:09:53,440
Так что добавив только ID в качестве ссылки, вы можете сослаться на весь объект пользователя, но

116
00:09:53,440 --> 00:09:56,840
без повторения всех его значений.

117
00:09:56,840 --> 00:10:01,000
Заметьте, что SQL-базы данных соответствуют ACID.

118
00:10:01,000 --> 00:10:06,200
Это означает атомарность, согласованность, изоляцию и устойчивость.

119
00:10:06,200 --> 00:10:08,080
Так что это на самом деле значит?

120
00:10:08,080 --> 00:10:13,800
Всякий раз, когда в реляционной базе данных есть транзакция, например обновление данных или нескольких

121
00:10:13,800 --> 00:10:20,360
фрагментов данных, согласованность и валидность данных гарантируется.

122
00:10:20,360 --> 00:10:25,200
Неважно, какие технические проблемы происходят во время этой транзакции.

123
00:10:25,200 --> 00:10:30,040
Эти технические проблемы могут быть сетевыми или аппаратными сбоями, это может быть сбой ПО, например

124
00:10:30,040 --> 00:10:34,560
сама база данных падает или приложение, и так далее.

125
00:10:34,560 --> 00:10:40,720
Например, если у вас есть транзакция, которая обновляет значения в 10 разных таблицах,

126
00:10:40,720 --> 00:10:48,280
и предположим, после обновления 5 таблиц сетевое соединение прервало транзакцию,

127
00:10:48,280 --> 00:10:53,040
но база данных гарантирует, что никаких половинчатых изменений не было сделано.

128
00:10:53,040 --> 00:10:58,440
И это достигается механизмом базы данных, который готовит все изменения, например все эти

129
00:10:58,440 --> 00:11:07,320
10 изменений, и если успешно — коммитит все изменения сразу, а если прерывается,

130
00:11:07,320 --> 00:11:10,800
то откатывает все изменения.

131
00:11:10,800 --> 00:11:17,360
То есть либо все изменения одной транзакции применяются к базе данных, либо ни одно из них

132
00:11:17,360 --> 00:11:18,880
не применяется.

133
00:11:18,880 --> 00:11:23,200
И это очень важно для банковских и финансовых приложений, верно?

134
00:11:23,200 --> 00:11:28,440
Классический пример: если деньги списаны с вашего счета, то

135
00:11:28,440 --> 00:11:32,960
они должны появиться на чьем-то другом счете или, возможно, на вашем другом счете.

136
00:11:32,960 --> 00:11:39,160
Если что-то происходит между этими действиями — деньги пропали со счета, и скажем,

137
00:11:39,160 --> 00:11:46,080
произошла сетевая ошибка или база данных упала, или приложение перестало работать, либо нужно

138
00:11:46,080 --> 00:11:52,920
откатить первое изменение, либо выполнить вторую часть изменения, иначе получается

139
00:11:52,920 --> 00:11:54,760
несогласованность.

140
00:11:54,760 --> 00:12:00,040
И именно в этом сценарии очень важно иметь такую согласованность.

141
00:12:00,040 --> 00:12:03,320
Так что это огромное преимущество таких баз данных.

142
00:12:03,320 --> 00:12:09,040
Но эта же функциональность делает SQL-базы данных очень сложными для масштабирования.

143
00:12:09,040 --> 00:12:16,480
Это означает, что запуск SQL-реляционных баз данных в распределенной среде, например в контейнерных

144
00:12:16,480 --> 00:12:22,200
кластерах и так далее, может быть сложным именно из-за этого механизма.

145
00:12:22,200 --> 00:12:29,320
Однако стоит отметить, что существуют современные SQL-базы вроде CockroachDB, которые специально

146
00:12:29,320 --> 00:12:35,920
созданы, чтобы решить эту проблему масштабируемости SQL-баз и легко работать на современной

147
00:12:35,920 --> 00:12:36,920
инфраструктуре.

148
00:12:36,920 --> 00:12:43,520
И наконец, следует упомянуть, что поскольку SQL до сих пор был так популярен, мы также

149
00:12:43,520 --> 00:12:50,400
говорим об этом сравнении между SQL и остальными типами баз данных как о противостоянии SQL и

150
00:12:50,400 --> 00:12:52,920
NoSQL.

151
00:12:52,920 --> 00:13:01,120
Теперь для двух сложных связей многие-ко-многим, которые в SQL требуют нескольких JOIN-ов или промежуточной таблицы,

152
00:13:01,120 --> 00:13:08,000
чтобы соединить такие связи многие-ко-многим, существует альтернатива,

153
00:13:08,000 --> 00:13:10,720
это графовые базы данных.

154
00:13:10,720 --> 00:13:13,400
Примером может быть Reddit.

155
00:13:13,400 --> 00:13:19,800
Например, у вас есть пользователь, который может состоять во многих Reddit-группах, и одна группа может иметь нескольких

156
00:13:19,800 --> 00:13:22,080
пользователей.

157
00:13:22,080 --> 00:13:28,480
Или на YouTube у меня может быть много подписчиков, и я могу быть подписан на множество каналов.

158
00:13:28,480 --> 00:13:34,440
Для таких случаев графовые базы данных подходят лучше всего, потому что они снимают часть

159
00:13:34,440 --> 00:13:39,860
сложности и уменьшают сложность такой связанной данных.

160
00:13:39,860 --> 00:13:46,440
Популярные примеры таких баз — Neo4j или Dgraph.

161
00:13:46,440 --> 00:13:52,920
В графовых базах данных вместо дополнительной промежуточной таблицы для связи пользователей

162
00:13:52,920 --> 00:13:59,640
и каналов или пользователей и групп мы можем напрямую соединять записи с помощью

163
00:13:59,640 --> 00:14:01,880
ребра как соединителя.

164
00:14:01,880 --> 00:14:08,920
И также проще запрашивать такие связанные данные в графовых базах, чем использовать несколько

165
00:14:08,920 --> 00:14:13,460
JOIN-ов, как в реляционных SQL-базах.

166
00:14:13,460 --> 00:14:18,780
Эти типы баз лучше всего подходят для обнаружения паттернов в данных приложения,

167
00:14:18,780 --> 00:14:26,740
для выявления связей между записями, а также для рекомендательных систем и

168
00:14:26,740 --> 00:14:28,060
тому подобного.

169
00:14:28,060 --> 00:14:33,140
И ещё один тип баз данных — поисковые базы.

170
00:14:33,140 --> 00:14:37,700
Представьте поисковик вроде Google, где вы вводите слово или несколько слов, комбинацию

171
00:14:37,700 --> 00:14:44,180
слов, и приложению нужно обыскать базу огромного объёма данных, чтобы найти наиболее

172
00:14:44,180 --> 00:14:48,340
релевантные результаты для введённых слов.

173
00:14:48,340 --> 00:14:54,140
Для этого нужна база данных, поддерживающая полнотекстовый поиск эффективно и быстро,

174
00:14:54,140 --> 00:14:59,300
потому что пользователи, как в Google, не хотят ждать минуты, чтобы получить

175
00:14:59,300 --> 00:15:01,660
результаты поиска.

176
00:15:01,660 --> 00:15:05,940
Примеры таких баз — Elasticsearch и Solr.

177
00:15:05,940 --> 00:15:11,220
Они работают похоже на документо-ориентированные базы, потому что у вас там тоже есть множество объектов данных.

178
00:15:11,220 --> 00:15:12,220
 

179
00:15:12,220 --> 00:15:17,260
Разница в том, что в фоне поисковая база анализирует весь текст из объектов данных

180
00:15:17,260 --> 00:15:23,620
и создаёт индекс всех отдельных слов или кусочков данных, как классический индекс

181
00:15:23,620 --> 00:15:26,620
в книгах.

182
00:15:26,620 --> 00:15:32,540
Когда пользователь выполняет поиск, база сканирует только индекс релевантных результатов,

183
00:15:32,540 --> 00:15:39,300
вместо того чтобы искать по каждому документу в базе, что, конечно, делает поиск

184
00:15:39,300 --> 00:15:42,700
по большим наборам данных значительно быстрее.

185
00:15:42,700 --> 00:15:48,140
Это основные типы баз данных, и, как я упомянул, исходя из потребностей вашего приложения

186
00:15:48,140 --> 00:15:55,900
или конкретного кейса, нужно выбирать правильную базу

187
00:15:55,900 --> 00:15:58,460
для использования в вашем приложении.

188
00:15:58,460 --> 00:16:03,580
Или, как вы тоже видели, это может быть комбинация баз: у вас может быть реляционная

189
00:16:03,580 --> 00:16:08,100
база, которая обрабатывает и хранит большую часть данных.

190
00:16:08,100 --> 00:16:13,620
Дополнительно вы можете иметь поисковую базу, чтобы отдельно обрабатывать поиск,

191
00:16:13,620 --> 00:16:20,300
и также кеш, чтобы обеспечить быструю работу приложения и дать пользователям ощущение

192
00:16:20,300 --> 00:16:28,020
реального времени, используя базу ключ-значение вроде Redis

193
00:16:28,020 --> 00:16:29,500
или Memcached для этого.

