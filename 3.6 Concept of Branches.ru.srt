1
00:00:00,000 --> 00:00:11,400
Видите, здесь у нас есть ветка master, у нас только одна ветка, которая создается

2
00:00:11,400 --> 00:00:14,480
по умолчанию при создании репозитория.

3
00:00:14,480 --> 00:00:19,900
Так что же такое ветки и почему она называется master?

4
00:00:19,900 --> 00:00:25,720
Типичный сценарий в команде разработки - вы делаете новые функции для приложения

5
00:00:25,720 --> 00:00:29,400
или исправляете ошибки в существующих функциях.

6
00:00:29,400 --> 00:00:34,000
А теперь представьте, три разработчика создают новые функции, а еще двое разработчиков

7
00:00:34,000 --> 00:00:38,960
чинят какие-то баги, и каждый делает свои изменения кода.

8
00:00:38,960 --> 00:00:46,520
Мы сказали, что важно коммитить изменения часто и маленькими порциями в ветку master,

9
00:00:46,520 --> 00:00:49,400
в основную ветку репозитория.

10
00:00:49,400 --> 00:00:54,440
Представьте, если бы каждый разработчик пушил свои изменения в репозиторий, что за бардак с этим репозиторием

11
00:00:54,440 --> 00:00:55,440
получился бы.

12
00:00:55,440 --> 00:00:58,280
Мы не знаем фактическое состояние репозитория.

13
00:00:58,280 --> 00:01:02,480
Два бага полностью исправлены или только частично?

14
00:01:02,480 --> 00:01:07,480
Три фичи полностью реализованы или еще не работают?

15
00:01:07,480 --> 00:01:13,120
Никто не мог бы сказать, когда репозиторий в таком состоянии, что можно собирать приложение

16
00:01:13,120 --> 00:01:19,520
и куда-то его деплоить на основе текущего состояния репозитория.

17
00:01:19,520 --> 00:01:27,320
Поэтому концепция веток существует, чтобы четко разделять работу разных разработчиков.

18
00:01:27,320 --> 00:01:33,160
Лучшая практика - создавать ветку для каждой фичи и каждого бага.

19
00:01:33,160 --> 00:01:37,760
И этот git-репозиторий тоже поддерживает эти лучшие практики.

20
00:01:37,760 --> 00:01:46,640
Так что если я зайду в ветки, у меня всего одна ветка, как видите, я могу создать новую.

21
00:01:46,640 --> 00:01:53,720
Стандарт именования веток с фичами и багфиксами - префиксировать их

22
00:01:53,720 --> 00:01:55,360
либо feature.

23
00:01:55,360 --> 00:02:04,160
А потом имя фичи, например authentication, user authentication.

24
00:02:04,160 --> 00:02:14,040
А если я чиню баг, например, это будет bugfix user authentication error или что-то такое.

25
00:02:14,040 --> 00:02:21,320
По сути, мы используем ветки также как описание того, что происходит в ветке, какие изменения

26
00:02:21,320 --> 00:02:27,720
кода в процессе, какая новая фича разрабатывается или какой баг

27
00:02:27,720 --> 00:02:30,560
исправляется в этой ветке, верно?

28
00:02:30,560 --> 00:02:34,080
Так что опять же, это хорошо для четкого разделения.

29
00:02:34,080 --> 00:02:40,560
И у вас одна ветка на багфикс или на фичу - это лучшие практики.

30
00:02:40,560 --> 00:02:47,320
Теперь разработчик может коммитить свои недоделанные или WIP-изменения так часто, как

31
00:02:47,320 --> 00:02:50,440
хочет, не ломая чужой код.

32
00:02:50,440 --> 00:02:56,400
И когда все полностью реализовано и локально протестировано, разработчик может сказать: моя фича или мой баг

33
00:02:56,400 --> 00:03:01,560
фикс готов, я могу смержить его в ветку master.

34
00:03:01,560 --> 00:03:04,800
Так что все остальные тоже смогут это использовать.

35
00:03:04,800 --> 00:03:11,960
И новая фича может быть задеплоена в следующей версии релиза.

36
00:03:11,960 --> 00:03:15,200
То есть каждый разработчик работает со своей веткой.

37
00:03:15,200 --> 00:03:20,600
И когда заканчивают свои изменения, они мержат их обратно в master.

38
00:03:20,600 --> 00:03:27,000
Важно отметить: если фичи слишком большие, их полная реализация может занять много времени

39
00:03:27,000 --> 00:03:28,520
для одной фичи.

40
00:03:28,520 --> 00:03:35,200
И это увеличит вероятность конфликтов, когда придет время мержить несколько таких фич

41
00:03:35,200 --> 00:03:36,600
в master.

42
00:03:36,600 --> 00:03:41,200
Поэтому важно иметь небольшие фичи, которые не занимают много

43
00:03:41,200 --> 00:03:44,120
дней или недель на реализацию.

44
00:03:44,120 --> 00:03:48,560
Иначе разработчикам придется постоянно общаться и решать конфликты при слиянии.

45
00:03:48,560 --> 00:03:53,560
В результате в команде вы всегда знаете текущее состояние master и

46
00:03:53,560 --> 00:04:00,680
знаете, что в master нет наполовину сделанных или незавершенных фич или багфиксов.

47
00:04:00,680 --> 00:04:05,840
И что ее всегда можно деплоить, так сказать, она всегда готова к релизу.

48
00:04:05,840 --> 00:04:10,520
Итак, есть два способа создать ветку: мы можем создать ее в UI, как я показал

49
00:04:10,520 --> 00:04:18,160
здесь, любой репозиторий позволяет создавать ветку в UI, можем сделать это здесь, можем

50
00:04:18,160 --> 00:04:21,600
вообще оставить этот багфикс - создать ветку.

51
00:04:21,600 --> 00:04:26,120
И обратите внимание, что мы создали ветку на основе master, верно?

52
00:04:26,120 --> 00:04:33,040
Итак, у нас сейчас ровно тот же код, скопированный из master, и он вынесен в новую ветку.

53
00:04:33,040 --> 00:04:36,880
И теперь мы можем вносить изменения в этой ветке.

54
00:04:36,880 --> 00:04:39,920
И это отведёт ветку от master, верно?

55
00:04:39,920 --> 00:04:43,200
Но нам нужно основываться на какой-то ветке.

56
00:04:43,200 --> 00:04:47,840
И опять же, лучшая практика — делать это от master.

57
00:04:47,840 --> 00:04:55,040
И теперь, если я хочу работать с этой веткой, которую создал в UI, мой локальный репозиторий Git

58
00:04:55,040 --> 00:04:57,760
не знает, что эта ветка была создана.

59
00:04:57,760 --> 00:05:03,240
Это значит, что если я здесь выполню git branch, я увижу только одну ветку, верно?

60
00:05:03,240 --> 00:05:05,240
Я вижу только master.

61
00:05:05,240 --> 00:05:08,560
Значит, мой локальный репозиторий Git должен узнать, что есть новая ветка.

62
00:05:08,560 --> 00:05:13,760
Для этого мы просто подтягиваем изменения из репозитория.

63
00:05:13,760 --> 00:05:19,320
И здесь вы видите, я получил обновление: новая ветка создана, и вот её имя, верно?

64
00:05:19,320 --> 00:05:21,600
Итак, я всё ещё в master.

65
00:05:21,600 --> 00:05:25,680
Так как же мне начать работать в той новой ветке?

66
00:05:25,680 --> 00:05:30,760
Я делаю это с помощью команды git checkout.

67
00:05:30,760 --> 00:05:37,220
То есть git checkout по сути позволяет мне сменить ветку, в которой я работаю.

68
00:05:37,220 --> 00:05:42,400
Если я это сделаю, вы увидите: теперь у меня есть локальная копия ветки, которая связана с

69
00:05:42,400 --> 00:05:44,960
удалённой веткой.

70
00:05:44,960 --> 00:05:48,000
И теперь я переключился на эту ветку.

71
00:05:48,000 --> 00:05:54,760
Поэтому каждое изменение, которое я теперь делаю в коде, затронет только эту ветку.

72
00:05:54,760 --> 00:06:01,360
Другой способ создать новую ветку — тот, которым я чаще всего пользуюсь, потому что он удобнее

73
00:06:01,360 --> 00:06:05,080
и быстрее — использовать командную строку, верно?

74
00:06:05,080 --> 00:06:10,880
Допустим, я начинаю работать над фичей, которая добавит новую функциональность.

75
00:06:10,880 --> 00:06:14,200
Скажем, я подключаюсь к новой базе данных.

76
00:06:14,200 --> 00:06:19,720
Первое, что мне нужно сделать, — вернуться в master, потому что, опять же, мы основываем

77
00:06:19,720 --> 00:06:25,320
новую фичевую ветку или ветку исправления багов на коде master, верно?

78
00:06:25,320 --> 00:06:31,280
Поэтому я собираюсь выполнить checkout master.

79
00:06:31,280 --> 00:06:37,400
И теперь, когда у меня актуальное состояние master, я могу создать новую ветку и

80
00:06:37,400 --> 00:06:43,320
я могу сделать это с помощью git checkout.

81
00:06:43,320 --> 00:06:52,040
И здесь я указываю флаг, опцию минус B. И теперь я могу написать имя своей фичевой

82
00:06:52,040 --> 00:06:53,040
ветки.

83
00:06:53,040 --> 00:06:57,480
Например, database connection, верно?

84
00:06:57,480 --> 00:06:59,840
Сейчас этой фичевой ветки ещё не существует.

85
00:06:59,840 --> 00:07:07,320
Поэтому с этой опцией Git создаст эту ветку этой командой и также выполнит checkout

86
00:07:07,320 --> 00:07:08,320
в эту ветку.

87
00:07:08,320 --> 00:07:10,960
То есть он сделает две вещи одной командой.

88
00:07:10,960 --> 00:07:16,040
И вот вы видите: ветка создана, и я автоматически переключился на эту ветку.

89
00:07:16,040 --> 00:07:19,280
Для меня это намного быстрее и эффективнее.

90
00:07:19,280 --> 00:07:23,680
Мне не нужно возвращаться в UI, создавать там ветку и потом подтягивать её.

91
00:07:23,680 --> 00:07:26,600
Я могу сделать это локально быстрее.

92
00:07:26,600 --> 00:07:33,280
Теперь у меня есть локально ветка: если снова выполнить git branch, у меня есть ветка master, есть

93
00:07:33,280 --> 00:07:38,680
bug fix, которую я подтянул, и есть фичевая ветка, которую я только что создал.

94
00:07:38,680 --> 00:07:42,720
Теперь удалённый репозиторий не знает об этой фичевой ветке.

95
00:07:42,720 --> 00:07:49,880
Так что если я вернусь и обновлю, вы видите, здесь только две ветки, верно?

96
00:07:49,880 --> 00:07:55,960
Так что у нас снова та же ситуация: в моём локальном репозитории есть ветка, но удалённый

97
00:07:55,960 --> 00:07:57,840
должен о ней знать, верно?

98
00:07:57,840 --> 00:08:04,200
Итак, ветку bug fix мы подтянули из репозитория, а новую фичевую ветку

99
00:08:04,200 --> 00:08:07,400
нам нужно запушить в удалённый репозиторий.

100
00:08:07,400 --> 00:08:10,520
Чтобы он узнал о новой фичевой ветке.

101
00:08:10,520 --> 00:08:13,200
Итак, сначала давайте внесем несколько изменений.

102
00:08:13,200 --> 00:08:18,160
Сейчас оно точно в том же состоянии, что и master.

103
00:08:18,160 --> 00:08:21,120
Давайте сделаем что-нибудь совсем тривиальное.

104
00:08:21,120 --> 00:08:28,680
Просто обновим readme, чтобы было что закоммитить.

105
00:08:28,680 --> 00:08:36,320
Просто поменяем это здесь, устанавливая все зависимости.

106
00:08:36,320 --> 00:08:42,120
Конечно, в реальном случае я бы изменил код, который действительно подключается к базе данных,

107
00:08:42,120 --> 00:08:56,440
внес бы какие-то изменения в код, а потом закоммитил эти изменения, то есть не так уж важно.

108
00:08:56,440 --> 00:09:01,080
И давайте очистим это и сделаем git status.

109
00:09:01,080 --> 00:09:05,880
Нечего коммитить, но у меня есть новый коммит, который нужно запушить в репозиторий.

110
00:09:05,880 --> 00:09:08,960
Что же произойдет, если я сделаю git push?

111
00:09:08,960 --> 00:09:16,200
Здесь мы видим, что просто git push не работает, потому что, как я сказал, удаленный репозиторий не знает

112
00:09:16,200 --> 00:09:17,640
о feature-ветке.

113
00:09:17,640 --> 00:09:24,840
Так что он говорит: у меня нет ветки, куда я могу слить эти изменения из вашего локального репозитория

114
00:09:24,840 --> 00:09:26,160
туда, да.

115
00:09:26,160 --> 00:09:29,960
То есть нам нужно запушить саму ветку.

116
00:09:29,960 --> 00:09:32,080
А затем изменения в ветке.

117
00:09:32,080 --> 00:09:35,920
Делаем это с помощью этой команды.

118
00:09:35,920 --> 00:09:45,040
Git push set upstream origin feature branch — этот пуш отправляет ветку в удаленный репозиторий.

119
00:09:45,040 --> 00:09:55,600
И теперь, если я вернусь и раскрою список, я вижу feature-ветку прямо здесь.

120
00:09:55,600 --> 00:10:02,880
И одно, что нужно помнить здесь: вам не нужно запоминать все эти команды.

121
00:10:02,880 --> 00:10:08,840
Например, я никогда не набираю полностью эти git push set upstream, потому что я знаю, что когда набираю

122
00:10:08,840 --> 00:10:15,640
git push, он даст мне подсказку команды, которую я могу просто скопировать, верно?

123
00:10:15,640 --> 00:10:19,840
Так что вам не нужно запоминать эти вещи, вам не нужно запоминать pull requests,

124
00:10:19,840 --> 00:10:26,480
и так далее с атрибутами, потому что git дает вам много подсказок,

125
00:10:26,480 --> 00:10:27,980
так сказать.

126
00:10:27,980 --> 00:10:31,840
Но важно знать концепции, важно знать, что когда вы создаете ветку

127
00:10:31,840 --> 00:10:37,320
в удаленном репозитории, локальная ветка должна притянуть это изменение, иначе она

128
00:10:37,320 --> 00:10:39,200
не знает, что есть новая ветка.

129
00:10:39,200 --> 00:10:43,640
И так же, если вы делаете какие-то изменения в локальном репозитории, вы должны дать

130
00:10:43,640 --> 00:10:45,520
знать удаленному.

131
00:10:45,520 --> 00:10:50,000
И когда вы знаете концепции, вы можете подсмотреть команды или просто фактически

132
00:10:50,000 --> 00:10:53,160
использовать те, что предлагает вам git.

133
00:10:53,160 --> 00:10:59,080
Еще одна вещь, на которую стоит обратить внимание, это то, что во многих проектах и командах на самом деле есть

134
00:10:59,080 --> 00:11:01,360
две основные ветки.

135
00:11:01,360 --> 00:11:08,440
То есть у них есть master-ветка и есть develop-ветка или dev-ветка, так сказать.

136
00:11:08,440 --> 00:11:11,240
Это очень распространенная практика.

137
00:11:11,240 --> 00:11:16,680
То есть dev-ветка по сути представляет промежуточный master, верно?

138
00:11:16,680 --> 00:11:22,000
Мы говорили, что master всегда должен быть в таком состоянии, в котором все разработчики знают, что это

139
00:11:22,000 --> 00:11:25,600
состояние готово к продакшену, верно?

140
00:11:25,600 --> 00:11:27,440
Это протестированный код.

141
00:11:27,440 --> 00:11:32,240
Это что-то, что является кандидатом на следующий релиз, так сказать.

142
00:11:32,240 --> 00:11:38,180
Как это работает: команды, которые работают спринтами, создают свои feature-

143
00:11:38,180 --> 00:11:43,400
ветки и ветки багфиксов и сливают их в develop-ветку.

144
00:11:43,400 --> 00:11:48,080
А в конце спринта, будь то двухнедельный период, трехнедельный или какой угодно

145
00:11:48,080 --> 00:11:52,880
develop-ветка потом сливается в master, верно?

146
00:11:52,880 --> 00:11:58,320
То есть они тестируют develop-ветку и все изменения, которые были сделаны там, и затем сливают ее в

147
00:11:58,320 --> 00:11:59,320
master.

148
00:11:59,320 --> 00:12:02,400
Теперь, в чем разница между этими двумя практиками?

149
00:12:02,400 --> 00:12:07,120
В чем разница между тем, чтобы иметь только master-ветку и постоянно вливать в нее эти ветки,

150
00:12:07,120 --> 00:12:12,160
или иметь дополнительную develop-ветку?

151
00:12:12,160 --> 00:12:19,600
Итак, если вы настраиваете и разрабатываете непрерывную интеграцию, непрерывную

152
00:12:19,600 --> 00:12:25,760
поставку, то вам следует использовать только ветку master, потому что работает это так,

153
00:12:25,760 --> 00:12:33,040
что каждое изменение кода, то есть каждый раз, когда завершается новая фича

154
00:12:33,040 --> 00:12:38,600
и вливается в ветку master, или каждый раз, когда завершается исправление бага и вливается в master,

155
00:12:38,600 --> 00:12:44,600
это запускает конвейер, который протестирует код и соберет

156
00:12:44,600 --> 00:12:49,240
приложение и задеплоит его хотя бы на staging-сервер, верно?

157
00:12:49,240 --> 00:12:51,640
Это и есть непрерывная доставка.

158
00:12:51,640 --> 00:12:57,040
И для этого вам нужна ветка dev, потому что вы не копите свои изменения.

159
00:12:57,040 --> 00:13:02,120
И затем в конце спринта не сливаете их в master и деплоите, а наоборот

160
00:13:02,120 --> 00:13:09,400
деплоите каждое исправление бага, каждую фичу сразу на staging-сервер.

161
00:13:09,400 --> 00:13:11,200
Это важно понимать.

162
00:13:11,200 --> 00:13:16,000
Когда у вас есть ветка develop как промежуточная к master, происходит следующее: разработчики

163
00:13:16,000 --> 00:13:23,920
по сути собирают новые фичи, исправления багов и все прочие изменения в dev.

164
00:13:23,920 --> 00:13:29,680
Затем они берут этот большой объем изменений в конце спринта, вливают его в master.

165
00:13:29,680 --> 00:13:34,040
То есть релиз выходит раз в конце спринта, верно?

166
00:13:34,040 --> 00:13:38,320
И здесь есть некоторые сложности, потому что ветка dev может в итоге оказаться

167
00:13:38,320 --> 00:13:44,800
состоянием work in progress, и им нужно быть аккуратными и синхронизироваться, когда приходит время

168
00:13:44,800 --> 00:13:47,840
сливать develop в master и так далее.

169
00:13:47,840 --> 00:13:54,440
Поэтому лучшая практика в DevOps, если вы хотите делать это современным способом, то есть

170
00:13:54,440 --> 00:13:59,440
правильно настроить непрерывную интеграцию и непрерывную доставку,

171
00:13:59,440 --> 00:14:05,960
заключается в том, что у вас есть ветка master, и вам не нужна промежуточная ветка dev

172
00:14:05,960 --> 00:14:06,960
больше.

173
00:14:06,960 --> 00:14:09,840
Так что на самом деле это и должна быть лучшая практика.

174
00:14:09,840 --> 00:14:13,440
Но для инженеров DevOps важно знать, что есть команды разработчиков,

175
00:14:13,480 --> 00:14:19,280
которые работают таким образом и имеют ветку dev, у некоторых даже есть третья ветка - это staging

176
00:14:19,280 --> 00:14:21,360
или дополнительная test-ветка.

177
00:14:21,360 --> 00:14:25,160
Поэтому важно знать, что они работают по таким практикам.

178
00:14:25,160 --> 00:14:31,360
А если вы хотите перейти на правильный DevOps-конвейер с непрерывной доставкой, вам нужно

179
00:14:31,360 --> 00:14:37,560
отказаться от этого и оставить только одну ветку master, а также собирать и доставлять

180
00:14:37,560 --> 00:14:41,000
изменения после каждого слияния в ветку master.

